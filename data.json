{
  "questions": [
    {
      "id": "A1Q1",
      "question": "Develop a menu driven program demonstrating the following operations on simple Queues: enqueue(), dequeue(), isEmpty(), isFull(), display(), and peek(). [cite: 3]",
      "answer": "#include <iostream>\nusing namespace std;\n#define SIZE 100 \n\nclass Queue_implementation{\nprivate:\n    int qu[SIZE];\n    int front, rear;\n\npublic:\n    Queue_implementation(){\n        front = -1;\n        rear = -1;\n    }\n\n    void enqueue(int element){\n        if(rear == SIZE - 1){\n            cout << \"Queue is Overflowed!\";\n        }\n        else{\n            if(front == rear && rear == -1){\n                front = 0;\n                rear = 0;\n                qu[rear] = element;\n            }\n            else{\n                rear++;\n                qu[rear] = element;\n            }\n        }\n    }\n\n    void dequeue(){\n        if(front > rear || front == -1){\n            cout << \"Queue is underflowed!\";\n        }\n        else{\n            front++;\n            // Optional: Reset front/rear if queue becomes empty after dequeue\n            if (front > rear) {\n                front = -1;\n                rear = -1;\n            }\n        }\n    }\n\n    bool isEmpty(){\n        return (front == -1 || front > rear);\n    }\n\n    bool isFull(){\n        return (rear == SIZE - 1);\n    }\n\n    int peek(){\n        if(isEmpty()){\n            cout << \"Queue is empty!\";\n            return -1;\n        }\n        else{\n            return qu[front];\n        }\n    }\n\n    void display(){\n        if(isEmpty()){\n            cout << \"Queue is empty!\";\n        }\n        else{\n            cout << \"Queue elements: \";\n            for(int i = front; i <= rear; i++){\n                cout << qu[i] << \" \";\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main(){\n    Queue_implementation q1;\n\n    int choice = 0;\n    while(choice != 7){\n        cout << \"Enter\" << endl;\n        cout << \"1. enqueue\" << endl;\n        cout << \"2. dequeue\" << endl;\n        cout << \"3. is Empty\" << endl;\n        cout << \"4. is Full\" << endl;\n        cout << \"5. display\" << endl;\n        cout << \"6. peek\" << endl;\n        cout << \"7. to exit\" << endl;\n\n    cin >> choice;\n    \n    switch(choice){\n        case 1:\n            int element;\n            cout << \"Enter the element you want for enqueue:\";\n            cin >> element;\n            q1.enqueue(element);\n            break;\n\n        case 2:\n            q1.dequeue();\n            break;\n\n        case 3:\n            cout << (q1.isEmpty() ? \"Queue is EMPTY\" : \"Queue is NOT empty\") << endl;\n            break;\n\n        case 4:\n            cout << (q1.isFull() ? \"Queue is FULL\" : \"Queue is NOT full\") << endl;\n            break;\n\n        case 5:\n            q1.display();\n            break;\n\n        case 6:\n            cout << \"Front element: \" << q1.peek() << endl;\n            break;\n        }\n    }\n    return 0;\n}"
    },
    {
      "id": "A1Q2",
      "question": "Develop a menu driven program demonstrating the following operations on Circular Queues: enqueue(), dequeue(), isEmpty(), isFull(), display(), and peek(). [cite: 4]",
      "answer": "#include <iostream>\nusing namespace std;\n#define SIZE 100 \n\nclass CircularQueue_Implementation{\nprivate:\n    int c_qu[SIZE];\n    int front, rear;\n\npublic:\n    CircularQueue_Implementation(){\n        front = -1;\n        rear = -1;\n    }\n\n    void enqueue(int element){\n        // Check for full condition: rear + 1 (mod SIZE) == front\n        if((rear + 1) % SIZE == front){\n            cout << \"Queue is Overflowed!\" << endl;\n        }\n        else{\n            // Handle first insertion\n            if(front == -1){\n                front = 0;\n            }\n            // Advance rear pointer and insert element\n            rear = (rear + 1) % SIZE;\n            c_qu[rear] = element;\n        }\n    } \n\n    void dequeue(){\n        // Check for empty condition: front == -1\n        if(front == -1){\n            cout << \"Queue is underflowed!\" << endl;\n        }\n        else{\n            // If it was the last element\n            if (front == rear){\n                front = -1;\n                rear = -1;\n            }\n            // Advance front pointer\n            else{\n                front = (front + 1) % SIZE;\n            }\n        }\n    }\n\n    bool isEmpty(){\n        return (front == -1);\n    }\n\n    bool isFull(){\n        return ((rear + 1) % SIZE == front);\n    }\n\n    int peek(){\n        if(isEmpty()){\n            cout << \"Queue is empty!\" << endl;\n            return -1;\n        }\n        else{\n            return c_qu[front];\n        }\n    }\n\n    void display(){\n        if(isEmpty()){\n            cout << \"Queue is empty!\" << endl;\n        }\n        else{\n            cout << \"Queue elements: \";\n            int i = front;\n            while(true){\n                cout << c_qu[i] << \" \";\n                if(i == rear){\n                    break;    \n                }      \n                i = (i + 1) % SIZE;          \n            }\n            cout << endl;\n        }\n    }\n\n};\n\nint main(){\n    CircularQueue_Implementation q1;\n\n    int choice = 0;\n    while(choice != 7){\n        cout << \"Enter\" << endl;\n        cout << \"1. enqueue\" << endl;\n        cout << \"2. dequeue\" << endl;\n        cout << \"3. is Empty\" << endl;\n        cout << \"4. is Full\" << endl;\n        cout << \"5. display\" << endl;\n        cout << \"6. peek\" << endl;\n        cout << \"7. to exit\" << endl;\n\n    cin >> choice;\n    \n    switch(choice){\n        case 1:\n            int element;\n            cout << \"Enter the element you want for enqueue:\";\n            cin >> element;\n            q1.enqueue(element);\n            break;\n\n        case 2:\n            q1.dequeue();\n            break;\n\n        case 3:\n            cout << (q1.isEmpty() ? \"Queue is EMPTY\" : \"Queue is NOT empty\") << endl;\n            break;\n\n        case 4:\n            cout << (q1.isFull() ? \"Queue is FULL\" : \"Queue is NOT full\") << endl;\n            break;\n            \n        case 5:\n            q1.display();\n            break;\n\n        case 6:\n            cout << \"Front element: \" << q1.peek() << endl;\n            break;\n        }\n    }\n    return 0;\n}"
    },
    {
      "id": "A1Q3",
      "question": "Write a program interleave the first half of the queue with second half. [cite: 5]",
      "answer": "#include <iostream>\nusing namespace std;\n#define SIZE 100 \n\nclass Queue_implementation{\nprivate:\n    int qu[SIZE];\n    int front, rear;\n\npublic:\n    Queue_implementation(){\n        front = -1;\n        rear = -1;\n    }\n\n    void enqueue(int element){\n        if(rear == SIZE - 1){\n            cout << \"Queue is Overflowed!\";\n        }\n        else{\n            if(front == -1){\n                front = 0;\n            }\n            rear++;\n            qu[rear] = element;\n        }\n    }\n\n    int dequeue(){\n        if(front == -1 || front > rear){\n            cout << \"Queue is underflowed!\";\n            return -1;\n        }\n        \n        int temp = qu[front];\n        front++;\n        if (front > rear) {\n            front = -1;\n            rear = -1;\n        }\n        return temp;\n    }\n\n    bool isEmpty(){\n        return (front == -1 || front > rear);\n    }\n\n    void display(){\n        if(isEmpty()){\n            cout << \"Queue is empty!\";\n        }\n        else{\n            cout << \"Queue elements: \";\n            for(int i = front; i <= rear; i++){\n                cout << qu[i] << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    int size(){\n        if (isEmpty()) return 0;\n        return (rear - front + 1);\n    }\n};\n\nvoid interleave(Queue_implementation &q1){\n    // Requires an auxiliary queue to store the first half\n    Queue_implementation q2;\n\n    int n = q1.size();\n    if (n % 2 != 0) { // Only works for even size queues. If odd, mid element remains in q1.\n        cout << \"Interleaving is typically done on even-sized queues. Proceeding with n/2 elements in first half.\" << endl;\n    }\n    \n    // 1. Move the first half to q2\n    for(int i = 0; i < n/2; i++){\n        q2.enqueue(q1.dequeue());\n    }\n\n    // 2. Interleave the elements (Q1, Q2, Q3, Q4, Q5, Q6 -> Q1, Q4, Q2, Q5, Q3, Q6)\n    // q2 has [Q1, Q2, Q3], q1 has [Q4, Q5, Q6]\n    while(!q2.isEmpty()){\n        // Q1 (from q2) -> q1 rear\n        q1.enqueue(q2.dequeue());\n        \n        // Q4 (from q1) -> q1 rear\n        q1.enqueue(q1.dequeue());\n    }\n    // Result for [4, 7, 11, 20, 5, 9] should be [4, 20, 7, 5, 11, 9]\n    // The logic in the provided code moves the second half's first element to the rear of q1 after each element from q2 is added,\n    // leading to a complicated order.\n    // The corrected standard interleaving logic is shown above and results in: [4, 20, 7, 5, 11, 9] (assuming size 6).\n}\n\nint main(){\n    Queue_implementation q1;\n\n    q1.enqueue(4);\n    q1.enqueue(7);\n    q1.enqueue(11);\n    q1.enqueue(20);\n    q1.enqueue(5);\n    q1.enqueue(9);\n\n    cout << \"Original queue: \";\n    q1.display(); // Output: 4 7 11 20 5 9\n\n    interleave(q1); \n\n    cout << \"Interleaved queue (Q1, Q4, Q2, Q5, ...): \";\n    q1.display(); // Output: 4 20 7 5 11 9\n\n    return 0;\n}"
    },
    {
      "id": "A1Q4",
      "question": "Write a program to find first non-repeating character in a string using Queue. [cite: 7]",
      "answer": "#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\n// Basic array-based Queue (adapted from Q1) for characters\n#define SIZE 100 \nclass Queue_implementation {\nprivate:\n    char qu[SIZE];\n    int front, rear;\n\npublic:\n    Queue_implementation() {\n        front = -1;\n        rear = -1;\n    }\n\n    void enqueue(char element) {\n        if(rear == SIZE - 1) { /* Queue Overflow check */ return; }\n        if(front == -1) front = 0;\n        rear++;\n        qu[rear] = element;\n    }\n\n    char dequeue() {\n        if(front == -1 || front > rear) { return '\\0'; }\n        char temp = qu[front];\n        front++;\n        if (front > rear) { front = -1; rear = -1; }\n        return temp;\n    }\n\n    bool isEmpty() {\n        return (front == -1 || front > rear);\n    }\n\n    char peek() {\n        if(isEmpty()) return '\\0';\n        return qu[front];\n    }\n};\n\nvoid non_repeating(string str) {\n    Queue_implementation q1;\n    // Map to store character frequency (using a vector/array of size 26 or 256 is often faster)\n    unordered_map<char, int> charCount;\n\n    for(char ch : str) {\n        // 1. Update frequency\n        charCount[ch]++;\n\n        // 2. Add the character to the queue\n        q1.enqueue(ch);\n\n        // 3. Remove repeating characters from the front of the queue\n        // The queue only holds characters seen once so far that are candidates for the first non-repeating char.\n        while(!q1.isEmpty() && charCount[q1.peek()] > 1) {\n            q1.dequeue();\n        }\n\n        // 4. Print the first non-repeating character at this step\n        if(q1.isEmpty()){\n            cout << -1 << \" \"; // No non-repeating character found yet\n        }\n        else{\n            cout << q1.peek() << \" \"; // First non-repeating character\n        }\n    }\n    cout << endl;\n}\n\nint main() {\n    string str;\n    cout << \"Enter string (e.g., aabc): \";\n    cin >> str;\n\n    non_repeating(str);\n    // Input: a a b c. Output: a -1 b b \n    return 0;\n}"
    },
    {
      "id": "A1Q5",
      "question": "Write a program to implement a stack using (a) Two queues and (b) One Queue. [cite: 9]",
      "answer": "#include <iostream>\nusing namespace std;\n#define SIZE 100 \n\n// Custom Queue class implementation for this solution\nclass Queue {\nprivate:\n    int qu[SIZE];\n    int front, rear;\n\npublic:\n    Queue() { front = -1; rear = -1; }\n    void enqueue(int element) {\n        if (rear == SIZE - 1) { /* Overflow */ return; }\n        if (front == -1) front = 0;\n        rear++;\n        qu[rear] = element;\n    }\n    int dequeue() {\n        if (front == -1 || front > rear) { return -1; }\n        int temp = qu[front];\n        front++;\n        if (front > rear) { front = -1; rear = -1; }\n        return temp;\n    }\n    int peek() {\n        if (front == -1 || front > rear) { return -1; }\n        return qu[front];\n    }\n    bool isEmpty() { return (front == -1 || front > rear); }\n    int size() { if (isEmpty()) return 0; return (rear - front + 1); }\n};\n\n// Implementation using One Queue (Costly Push - O(N))\nclass Stack {\nprivate:\n    Queue q; // Using the custom Queue implementation\n\npublic:\n    void push(int x) {\n        q.enqueue(x); // Add new element to the rear\n        \n        int s = q.size();\n        // Rotate the 's - 1' older elements to the rear of the new element\n        for (int i = 0; i < s - 1; i++) {\n            int val = q.dequeue();\n            q.enqueue(val);\n        }\n    }\n\n    int pop() {\n        if (q.isEmpty()) {\n            cout << \"Stack Underflow!\" << endl;\n            return -1;\n        }\n        return q.dequeue();\n    }\n\n    int top() {\n        int result = q.peek();\n        if (result == -1) {\n            cout << \"Stack Empty!\" << endl;\n        }\n        return result;\n    }\n\n    bool isEmpty() {\n        return q.isEmpty();\n    }\n};\n\nint main() {\n    Stack st;\n\n    st.push(10); \n    st.push(20); \n    st.push(30); \n\n    cout << \"Top: \" << st.top() << endl;  \n    cout << \"Pop: \" << st.pop() << endl;  \n    cout << \"Top: \" << st.top() << endl;  \n    st.pop();\n    st.pop();\n    st.pop(); // Underflow\n\n    return 0;\n}"
    },
    {
      "id": "A2Q1",
      "question": "Given a function n, write a function that generates and prints all binary numbers with decimal values from 1 to n. [cite: 11]",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateBinary(int n){\n    queue<string> q;\n    q.push(\"1\"); // Start with '1'\n    for(int i=1; i<=n; i++){\n        string s=q.front(); q.pop();\n        cout<<s<<(i<n?' ':'\\n'); // Print the current binary number\n        // Generate next two numbers\n        q.push(s+\"0\");\n        q.push(s+\"1\");\n    }\n}\n\nint main(){\n    int n=10;\n    cout << \"Binary numbers from 1 to \" << n << \":\" << endl;\n    generateBinary(n);\n    \n    n=2;\n    cout << \"Binary numbers from 1 to \" << n << \":\" << endl;\n    generateBinary(n);\n    return 0;\n}"
    },
    {
      "id": "A2Q2",
      "question": "Given a queue with random elements, we need to sort it. We are not allowed to use extra space. The operations allowed on queue are: 1. enqueue(): Adds an item to rear of queue. 2. dequeue(): Removes an item from front of queue. 3. isEmpty(): Checks if a queue is empty. [cite: 15, 17, 18, 19]",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to find the index of the minimum element in the unsorted part of the queue\nint minIndex(queue<int>& q, int sorted){\n    int n=q.size();\n    int minVal=INT_MAX, idx=-1;\n    // Iterate through all elements, but only consider the unsorted part for minimum\n    for(int i=0; i<n; i++){\n        int x=q.front(); q.pop();\n        // i <= n - sorted - 1 is the unsorted portion\n        if(i <= n - sorted - 1 && x < minVal){\n            minVal=x; \n            idx=i;\n        }\n        q.push(x); // Put element back\n    }\n    return idx;\n}\n\n// Function to move the element at minIdx to the rear of the queue\nvoid insertMinToRear(queue<int>& q, int minIdx){\n    int n=q.size();\n    int minVal=0;\n    // Move all elements from front to rear\n    for(int i=0; i<n; i++){\n        int x=q.front(); q.pop();\n        if(i == minIdx) {\n            minVal = x; // Keep the minimum value\n        }\n        else {\n            q.push(x); // Move others to the rear\n        }\n    }\n    q.push(minVal); // Insert the minimum element at the rear (now in sorted position)\n}\n\nvoid sortQueue(queue<int>& q){\n    int n = q.size();\n    // In each iteration, the minimum element is moved to its correct sorted position at the rear\n    for(int i=0; i<n; i++){ \n        // i represents the number of elements already sorted and placed at the rear\n        int idx=minIndex(q, i); \n        insertMinToRear(q, idx);\n    }\n}\n\nint main(){\n    queue<int> q;\n    for(int x: {11,5,4,21}) q.push(x); // Input: 11, 5, 4, 21 [cite: 20]\n    cout << \"Original Queue: 11 5 4 21\" << endl;\n    sortQueue(q);\n    cout << \"Sorted Queue: \";\n    while(!q.empty()){ \n        cout << q.front() << (q.size()>1?' ':'\\n'); \n        q.pop(); \n    }\n    // Output: 4, 5, 11, 21 [cite: 21]\n    return 0;\n}"
    },
    {
      "id": "A3Q1",
      "question": "Given a Queue consisting of first n natural numbers (in random order). The task is to check whether the given Queue elements can be arranged in increasing order in another Queue using a stack. The operation allowed are: 1. Push and pop elements from the stack 2. Pop (Or Dequeue) from the given Queue. 3. Push (Or Enqueue) in the another Queue. [cite: 23, 24, 25, 26, 27, 28]",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canBeSorted(queue<int> q){\n    stack<int> st;\n    int n=q.size();\n    int need=1; // The next element we need to move to the 'another Queue' (sorted queue)\n    \n    while(!q.empty()){\n        // Case 1: The element at the front of the main queue is the one we need\n        if(q.front() == need){\n            q.pop(); \n            need++; \n        }\n        // Case 2: The element at the top of the stack is the one we need\n        else if(!st.empty() && st.top() == need){\n            st.pop(); \n            need++; \n        }\n        // Case 3: Neither front nor top is the one we need, so push from queue to stack\n        else{\n            st.push(q.front()); \n            q.pop(); \n        }\n    }\n    \n    // After the main queue is empty, check if we can empty the stack into the sorted sequence\n    while(!st.empty() && st.top() == need){\n        st.pop(); \n        need++; \n    }\n    \n    // If 'need' has successfully reached n+1, it means all numbers from 1 to n were moved in order.\n    return need == n + 1;\n}\n\nint main(){\n    queue<int> q;\n    // Input: Queue = { 5, 1, 2, 3, 4} [cite: 29]\n    for(int x: {5,1,2,3,4}) q.push(x);\n    cout << \"Can the queue be sorted? \" << (canBeSorted(q) ? \"Yes\" : \"No\") << '\\n'; // Output: Yes [cite: 30]\n    \n    queue<int> q2;\n    for(int x: {4, 1, 3, 2}) q2.push(x);\n    cout << \"Can the queue {4, 1, 3, 2} be sorted? \" << (canBeSorted(q2) ? \"Yes\" : \"No\") << '\\n'; // Output: No\n    return 0;\n}"
    },
    {
      "id": "A7Q1",
      "question": "Write a program to implement following sorting techniques: a. Selection Sort, b. Insertion Sort, c. Bubble Sort, d. Merge Sort, e. Quick Sort.",
      "answer": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Utility function to print the array\nvoid print(const vector<int> &a) {\n    for(int x : a) cout << x << \" \";\n    cout << \"\\n\";\n}\n\n// a. Selection Sort\nvoid selectionSort(vector<int>& a) {\n    int n = a.size();\n    for(int i = 0; i < n - 1; i++) {\n        int minIndex = i;\n        for(int j = i + 1; j < n; j++)\n            if(a[j] < a[minIndex])\n                minIndex = j;\n        swap(a[i], a[minIndex]);\n    }\n}\n\n// b. Insertion Sort\nvoid insertionSort(vector<int>& a) {\n    int n = a.size();\n    for(int i = 1; i < n; i++) {\n        int key = a[i];\n        int j = i - 1;\n        while(j >= 0 && a[j] > key) {\n            a[j+1] = a[j];\n            j--;\n        }\n        a[j+1] = key;\n    }\n}\n\n// c. Bubble Sort\nvoid bubbleSort(vector<int>& a) {\n    int n = a.size();\n    bool swapped;\n    for(int i = 0; i < n - 1; i++) {\n        swapped = false;\n        for(int j = 0; j < n - i - 1; j++) {\n            if(a[j] > a[j+1]) {\n                swap(a[j], a[j+1]);\n                swapped = true;\n            }\n        }\n        if(!swapped) break; \n    }\n}\n\n// Helper for Merge Sort: Merge two subarrays\nvoid merge(vector<int>& a, int l, int m, int r) {\n    int n1 = m - l + 1, n2 = r - m;\n    vector<int> L(n1), R(n2);\n\n    for(int i = 0; i < n1; i++) L[i] = a[l + i];\n    for(int j = 0; j < n2; j++) R[j] = a[m + 1 + j];\n\n    int i = 0, j = 0, k = l;\n\n    while(i < n1 && j < n2) {\n        if(L[i] <= R[j]) a[k++] = L[i++];\n        else a[k++] = R[j++];\n    }\n    while(i < n1) a[k++] = L[i++];\n    while(j < n2) a[k++] = R[j++];\n}\n\n// d. Merge Sort\nvoid mergeSort(vector<int>& a, int l, int r) {\n    if(l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(a, l, m);\n        mergeSort(a, m+1, r);\n        merge(a, l, m, r);\n    }\n}\n\n// Helper for Quick Sort: Partition the array\nint partition(vector<int>& a, int low, int high) {\n    int pivot = a[high];\n    int i = low - 1;\n\n    for(int j = low; j < high; j++) {\n        if(a[j] < pivot) {\n            i++;\n            swap(a[i], a[j]);\n        }\n    }\n    swap(a[i+1], a[high]);\n    return i + 1;\n}\n\n// e. Quick Sort\nvoid quickSort(vector<int>& a, int low, int high) {\n    if(low < high) {\n        int pi = partition(a, low, high);\n        quickSort(a, low, pi - 1);\n        quickSort(a, pi + 1, high);\n    }\n}\n\nint main() {\n    vector<int> data = {64, 25, 12, 22, 11};\n    vector<int> arr;\n    \n    // 1. Selection Sort\n    arr = data; selectionSort(arr); \n    cout << \"Selection Sort: \"; print(arr);\n\n    // 2. Insertion Sort\n    arr = data; insertionSort(arr); \n    cout << \"Insertion Sort: \"; print(arr);\n\n    // 3. Bubble Sort\n    arr = data; bubbleSort(arr); \n    cout << \"Bubble Sort: \"; print(arr);\n\n    // 4. Merge Sort\n    arr = data; mergeSort(arr, 0, arr.size() - 1); \n    cout << \"Merge Sort: \"; print(arr);\n\n    // 5. Quick Sort\n    arr = data; quickSort(arr, 0, arr.size() - 1); \n    cout << \"Quick Sort: \"; print(arr);\n    \n    return 0;\n}"
    },
    {
      "id": "A7Q2",
      "question": "A slightly improved selection sort - We know that selection sort algorithm takes the minimum on every pass on the array, and place it at its correct position. The idea is to take also the maximum on every pass and place it at its correct position. Implement this logic.",
      "answer": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to implement improved selection sort (finding min/max in one pass)\nvoid improvedSelectionSort(vector<int>& a) {\n    int left = 0, right = a.size() - 1;\n\n    while(left < right) {\n        int minIndex = left, maxIndex = left;\n\n        // Find min and max in the unsorted sub-array a[left...right]\n        for(int i = left; i <= right; i++) {\n            if(a[i] < a[minIndex]) minIndex = i;\n            if(a[i] > a[maxIndex]) maxIndex = i;\n        }\n\n        // Swap minimum element to the 'left' end\n        swap(a[left], a[minIndex]);\n\n        // Check if the original maximum element's index was 'left' (the position we just overwrote)\n        // If so, the new position of the maximum element is 'minIndex'\n        if(maxIndex == left) \n            maxIndex = minIndex;\n\n        // Swap maximum element to the 'right' end\n        swap(a[right], a[maxIndex]);\n\n        left++;\n        right--;\n    }\n}\n\nvoid print(const vector<int> &a) {\n    for(int x : a) cout << x << \" \";\n    cout << \"\\n\";\n}\n\nint main() {\n    vector<int> a = {2, 7, 3, 1, 9, 5, 4, 8};\n    cout << \"Original array: \";\n    print(a);\n\n    improvedSelectionSort(a);\n    \n    cout << \"Sorted array: \";\n    print(a);\n    \n    return 0;\n}"
    },
    {
      "id": "A9Q1",
      "question": "Write a program to implement the following graph algorithms: 1. Breadth First Search (BFS), 2. Depth First Search (DFS), 3. Minimum Spanning Tree (Kruskal and Prim), 4. Dijkstra's Shortest Path Algorithm.",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Global variables for graph representation and visited status\nvector<vector<int>> ug; // Undirected Graph Adjacency List (for BFS/DFS)\nvector<vector<pair<int,int>>> wg; // Weighted Graph Adjacency List (for Prim/Dijkstra)\nvector<int> vis;\n\n// 1. Breadth First Search (BFS)\nvoid runBFS(int start){\n    queue<int> q;\n    q.push(start);\n    vis[start] = 1;\n\n    cout << \"BFS traversal: \";\n    while(!q.empty()){\n        int x = q.front();\n        q.pop();\n        cout << x << \" \";\n\n        for(int nxt : ug[x]){\n            if(!vis[nxt]){\n                vis[nxt] = 1;\n                q.push(nxt);\n            }\n        }\n    }\n    cout << endl;\n}\n\n// Helper for DFS\nvoid dfs(int x){\n    vis[x] = 1;\n    cout << x << \" \";\n    for(int nxt : ug[x]){\n        if(!vis[nxt]) dfs(nxt);\n    }\n}\n\n// 2. Depth First Search (DFS)\nvoid runDFS(int start){\n    cout << \"DFS traversal: \";\n    dfs(start);\n    cout << endl;\n}\n\n// DSU for Kruskal (Union-Find structure)\nstruct DSU{\n    vector<int> p, r;\n    DSU(int n): p(n), r(n,0){\n        for(int i=0;i<n;i++) p[i] = i;\n    }\n    int find(int x){\n        if(p[x] == x) return x;\n        return p[x] = find(p[x]);\n    }\n    bool unite(int a,int b){\n        a = find(a);\n        b = find(b);\n        if(a == b) return false;\n        if(r[a] < r[b]) swap(a,b);\n        p[b] = a;\n        if(r[a] == r[b]) r[a]++;\n        return true;\n    }\n};\n\n// 3.a. Kruskal's Minimum Spanning Tree Algorithm\nint runKruskal(int n, vector<tuple<int,int,int>> &edges){\n    // Sort edges by weight\n    sort(edges.begin(), edges.end());\n    DSU d(n);\n    int cost = 0;\n\n    for(auto &e : edges){\n        int w,u,v;\n        tie(w,u,v) = e;\n        // If adding edge (u,v) does not form a cycle, add it to MST\n        if(d.unite(u,v)) cost += w;\n    }\n\n    return cost;\n}\n\n// 3.b. Prim's Minimum Spanning Tree Algorithm\nint runPrim(int n){\n    vector<int> used(n,0);\n    int cost = 0;\n\n    // Priority Queue: {weight, node}\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\n    pq.push({0,0}); // Start from node 0 with weight 0\n\n    while(!pq.empty()){\n        auto [w, node] = pq.top();\n        pq.pop();\n        if(used[node]) continue;\n\n        used[node] = 1;\n        cost += w;\n\n        // Add all neighbors of the current node to PQ\n        for(auto &nbr : wg[node]){\n            pq.push({nbr.second, nbr.first});\n        }\n    }\n\n    return cost;\n}\n\n// 4. Dijkstra's Shortest Path Algorithm\nvector<int> runDijkstra(int n, int start){\n    vector<int> dist(n, INT_MAX);\n    dist[start] = 0;\n\n    // Priority Queue: {distance, node}\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\n    pq.push({0,start});\n\n    while(!pq.empty()){\n        auto [d,u] = pq.top();\n        pq.pop();\n        if(d > dist[u]) continue; // Skip stale entries\n\n        for(auto &nbr : wg[u]){\n            int v = nbr.first;\n            int w = nbr.second;\n\n            // Relaxation step\n            if(dist[u] != INT_MAX && dist[u] + w < dist[v]){\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    return dist;\n}\n\n// Menu driven main function to test the algorithms\nint main(){\n    cout << \"Enter choice (1=BFS, 2=DFS, 3=MST, 4=Dijkstra): \";\n    int choice;\n    cin >> choice;\n\n    int n, m; // n=vertices, m=edges\n\n    if(choice == 1 || choice == 2){ \n        cout << \"Enter number of vertices (N) and edges (M): \";\n        cin >> n >> m;\n        ug.assign(n, {});\n        vis.assign(n, 0);\n        cout << \"Enter M edges (u v):\\n\";\n        while(m--){\n            int u, v;\n            cin >> u >> v;\n            ug[u].push_back(v);\n            ug[v].push_back(u); // Undirected\n        }\n\n        int start;\n        cout << \"Enter start node: \";\n        cin >> start;\n        if (choice == 1) runBFS(start);\n        else runDFS(start);\n    }\n\n    else if(choice == 3){ \n        cout << \"Enter number of vertices (N) and edges (M): \";\n        cin >> n >> m;\n        vector<tuple<int,int,int>> edges; // For Kruskal: {w, u, v}\n        wg.assign(n, {}); // For Prim\n        cout << \"Enter M edges (u v w):\\n\";\n        while(m--){\n            int u, v, w;\n            cin >> u >> v >> w;\n            edges.push_back({w,u,v});\n            wg[u].push_back({v,w});\n            wg[v].push_back({u,w}); // Undirected\n        }\n\n        int kruskalCost = runKruskal(n, edges);\n        int primCost = runPrim(n);\n        cout << \"Minimum Spanning Tree Cost (Kruskal): \" << kruskalCost << endl;\n        cout << \"Minimum Spanning Tree Cost (Prim): \" << primCost << endl;\n    }\n\n    else if(choice == 4){ \n        cout << \"Enter number of vertices (N) and directed edges (M): \";\n        cin >> n >> m;\n        wg.assign(n, {});\n        cout << \"Enter M directed edges (u v w):\\n\";\n        while(m--){\n            int u, v, w;\n            cin >> u >> v >> w;\n            wg[u].push_back({v,w}); // Directed\n        }\n\n        int start;\n        cout << \"Enter start node: \";\n        cin >> start;\n\n        vector<int> dist = runDijkstra(n, start);\n\n        cout << \"Shortest distance from node \" << start << \" to all others:\\n\";\n        for(int i=0; i<n; i++) {\n             cout << \"Node \" << i << \": \" << (dist[i] == INT_MAX ? \"INF\" : to_string(dist[i])) << endl; \n        }\n    }\n\n    return 0;\n}"
    },
    {
      "id": "A10Q1",
      "question": "Given an integer array, check if it contains any duplicates using hash set.",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> nums = {1, 2, 3, 1}; // Example input\n    unordered_set<int> s;\n    bool hasDuplicate = false;\n    \n    for(int x: nums){\n        // Check if element is already present in the set\n        if(s.count(x)){\n            hasDuplicate = true;\n            break;\n        }\n        // Insert element into the set\n        s.insert(x);\n    }\n    \n    cout << (hasDuplicate ? \"true\" : \"false\") << endl;\n    return 0;\n}"
    },
    {
      "id": "A10Q2",
      "question": "Given two arrays, find the common elements using a hash set.",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> A = {1, 2, 3, 4}; // Example input A\n    vector<int> B = {3, 4, 5, 6}; // Example input B\n    \n    // Insert all elements of A into a hash set for quick lookup\n    unordered_set<int> s(A.begin(), A.end());\n    \n    cout << \"Common elements: \";\n    for(int x: B){\n        // Check if element from B is present in the set (and thus in A)\n        if(s.count(x)) {\n            cout << x << \" \";\n        }\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "id": "A10Q3",
      "question": "Count the frequency of each number in an array using a hash map.",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> nums = {2, 3, 2, 4, 3, 2}; // Example input\n    unordered_map<int, int> m; // Hash map to store {number: frequency}\n    \n    // Populate the frequency map\n    for(int x: nums) m[x]++;\n    \n    // Print the frequencies\n    for(auto &p: m){\n        cout << p.first << \" -> \" << p.second << \" times\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
      "id": "A10Q4",
      "question": "Find the first non-repeating element in an array using a hash map.",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> a = {4, 5, 1, 2, 0, 4}; // Example input\n    unordered_map<int, int> m; // Hash map to store frequency\n    \n    // 1. Calculate frequencies\n    for(int x: a) m[x]++;\n    \n    cout << \"First non-repeating element: \";\n    // 2. Iterate through the array again (to maintain order)\n    for(int x: a){\n        // Check frequency in the map\n        if(m[x] == 1){\n            cout << x << endl;\n            break;\n        }\n    }\n    \n    return 0;\n}"
    },
    {
      "id": "A10Q5",
      "question": "Given a linked list, determine whether it contains a loop (cycle) using a hash set.",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for singly-linked list node\nstruct Node{\n    int val;\n    Node* next;\n    Node(int v): val(v), next(NULL){}\n};\n\nint main(){\n    // Example: 1 -> 2 -> 3 -> 4 -> 2 (cycle back to node 2)\n    Node* a = new Node(1);\n    Node* b = new Node(2);\n    Node* c = new Node(3);\n    Node* d = new Node(4);\n    a->next = b;\n    b->next = c;\n    c->next = d;\n    d->next = b; // Creates the cycle\n\n    unordered_set<Node*> s; // Hash set to store visited nodes\n    Node* cur = a;\n    bool hasCycle = false;\n    \n    while(cur){\n        // If the current node is already in the set, a cycle is detected\n        if(s.count(cur)){\n            hasCycle = true;\n            break;\n        }\n        // Add the current node to the set\n        s.insert(cur);\n        cur = cur->next;\n    }\n    \n    // Clean up memory (optional for this demo, but good practice)\n    // Note: Careful cleanup needed for cyclic lists to avoid infinite loop\n    // For this demonstration, we focus on the detection logic.\n\n    cout << (hasCycle ? \"true\" : \"false\") << endl;\n    return 0;\n}"
    },
    {
      "id": "A10Q6",
      "question": "You are given a binary tree (not a binary search tree). Write a program to check if the tree contains any duplicate node values using hash set.",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for binary tree node\nstruct Node{\n    int val;\n    Node* left;\n    Node* right;\n    Node(int v): val(v), left(NULL), right(NULL){}\n};\n\n// DFS traversal to check for duplicates\nbool dfs(Node* root, unordered_set<int> &s){\n    if(!root) return false; // Base case: leaf or empty subtree\n    \n    // Check current node's value\n    if(s.count(root->val)) return true; // Duplicate found\n    \n    // Record the current node's value\n    s.insert(root->val);\n    \n    // Recurse on children\n    return dfs(root->left, s) || dfs(root->right, s);\n}\n\nint main(){\n    // Example: Tree with duplicate value '3'\n    Node* root = new Node(5);\n    root->left = new Node(3);\n    root->right = new Node(7);\n    root->left->left = new Node(3); // Duplicate node\n\n    unordered_set<int> s;\n    \n    if(dfs(root, s)) cout << \"Duplicates Found\" << endl;\n    else cout << \"No Duplicates\" << endl;\n    \n    return 0;\n}"
    },
    {
      "id": "A5Q1",
      "question": "Develop a menu driven program for the following standard operations on a Singly Linked List: Insertion (at beginning, end, and at a specific value/position), Deletion (from beginning, end, value, and position), Search, and Display.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node{\npublic:\n    int data;\n    Node *next;\n\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass LinkedList{\nprivate:\n    Node *head;\n\npublic:\n    LinkedList(){\n        head = nullptr;\n    }\n\n    void insertAtBeginning(int value){\n        Node * newNode = new Node(value);\n        newNode->next = head;\n        head = newNode;\n    }\n\n    void insertAtEnd(int value){\n        Node * newNode = new Node(value);\n        if(head == nullptr){\n            head = newNode;\n        }\n        else{\n            Node * current = head;\n            while(current->next != nullptr){\n                current = current->next;\n            }\n            current->next = newNode;\n        }\n    }\n\n    void insertAtValue(int existingValue, int newValue){\n        Node * newNode = new Node(newValue);\n\n        if (head == nullptr){\n            head = newNode;\n        }\n        else{\n            Node * current = head;\n            while(current != nullptr && current->data != existingValue){\n                current = current->next;\n            }\n\n            if(current == nullptr){\n                cout << \"Value not found, node not created!\";\n                delete newNode;\n            }\n            else{\n                newNode->next = current->next;\n                current->next = newNode; // Inserts AFTER the existingValue\n            }\n        }\n    }\n\n    void insertAtPosition(int value, int position){\n        Node * newNode = new Node(value);\n\n        if(position < 0){\n            cout << \"Please enter a valid Position!\";\n        }\n        else if(position == 0){\n            newNode->next = head;\n            head = newNode;\n        }\n        else{\n            Node * current = head;\n            int currentPosition = 0;\n\n            while(current != nullptr && currentPosition < position - 1){\n                current = current->next;\n                currentPosition++;\n            }\n\n            if(current == nullptr){\n                cout << \"No given Position found, No node created!\";\n                delete newNode;\n            }\n            else{\n                newNode->next = current->next;\n                current->next = newNode;\n            }\n        }\n    }\n    \n    void deleteAtBeginning(){\n        if(head == nullptr){\n            cout << \"Linked list is empty, Nothing to delete!\";\n        }\n        else{\n            Node * temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n\n    void deleteAtEnd(){\n        if(head == nullptr){\n            cout << \"Linked list is empty, Nothing to delete!\";\n        }\n        else if(head->next == nullptr){\n            delete head;\n            head = nullptr;\n        }\n        else{\n            Node * current = head;\n            while(current->next->next != nullptr){\n                current = current->next;\n            }\n            delete current->next;\n            current->next = nullptr;\n        }\n    }\n\n    void deleteAtValue(int value){\n        if(head == nullptr){\n            cout << \"Linked List is empty, Nothing to Delete!\";\n        }\n        else{\n            Node * temp = head;\n            Node * pre = nullptr;\n\n            while(temp != nullptr && temp->data != value){\n                pre = temp;\n                temp = temp->next;\n            }\n\n            if(temp == nullptr){\n                cout << \"Element not found!\";\n            }\n            else{\n                if(temp == head){\n                    head = head->next;\n                }\n                else{\n                    pre->next = temp->next;\n                }\n                delete temp;\n            }\n        }\n    }\n\n    void deleteAtPosition(int position){\n        if(position < 0){\n            cout << \"Please enter a valid position!\";\n        }\n        else if(head == nullptr){\n             cout << \"Linked list is empty, Nothing to delete!\";\n        }\n        else if(position == 0){\n            Node * temp = head;\n            head = head->next;\n            delete temp;\n        }\n        else{\n            Node * current = head;\n            int currentPosition = 0;\n\n            while(current != nullptr && currentPosition < position - 1){\n                current = current->next;\n                currentPosition++;\n            }\n\n            if(current == nullptr || current->next == nullptr){\n                cout << \"Position out of range!\";\n                return;\n            }\n\n            Node * temp = current->next;\n            current->next = current->next->next;\n            delete temp;\n        }\n    }\n\n    bool searchValue(int value){\n        if(head == nullptr){\n            cout << \"Linked list is empty, No element to search!\";\n            return false;\n        }\n        else{\n            Node * temp = head;\n            int pos = 0;\n            while(temp != nullptr){\n                if(temp->data == value){\n                    cout << \"Found at position \" << pos << \" from head. \";\n                    return true;\n                }\n                temp = temp->next;\n                pos++;\n            }\n            return false;\n        }\n    }\n\n    void display(){\n        if(head == nullptr){\n            cout << \"Linked list is empty, No element to display!\" << endl;\n        }\n        else{\n            Node * temp = head;\n            while(temp != nullptr){\n                cout << temp->data << \" \";\n                temp = temp->next;\n            }\n        }\n        cout << endl;\n    }\n};\n\n\nint main() {\n    LinkedList list;\n\n    cout << \"=== Insertion Tests ===\" << endl;\n    list.insertAtBeginning(10);\n    list.insertAtBeginning(5);\n    list.insertAtEnd(20);\n    list.insertAtEnd(30);\n    list.insertAtValue(20, 25); \n    list.insertAtPosition(15, 2);\n    cout << \"List after insertions (5 10 15 20 25 30): \";\n    list.display(); \n\n    cout << \"\\n=== Deletion Tests ===\" << endl;\n    list.deleteAtBeginning(); // Deletes 5\n    cout << \"After deleting beginning (10 15 20 25 30): \";\n    list.display(); \n\n    list.deleteAtEnd(); // Deletes 30\n    cout << \"After deleting end (10 15 20 25): \";\n    list.display(); \n\n    list.deleteAtValue(20); // Deletes 20\n    cout << \"After deleting value 20 (10 15 25): \";\n    list.display(); \n\n    list.deleteAtPosition(1); // Deletes 15\n    cout << \"After deleting position 1 (10 25): \";\n    list.display(); \n\n    cout << \"\\n=== Search Tests ===\" << endl;\n    cout << \"Searching for 25: \" << (list.searchValue(25) ? \"\" : \"Not Found\") << endl; // Output: Found at position 1 from head.\n    cout << \"Searching for 100: \" << (list.searchValue(100) ? \"Found\" : \"Not Found\") << endl; // Output: Not Found\n\n    cout << \"\\n=== Final List ===\" << endl;\n    list.display(); \n\n    return 0;\n}"
    },
    {
      "id": "A5Q2",
      "question": "Write a program to count the number of occurrences of a given key in a singly linked list and then delete all the occurrences.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node{\npublic:\n    int data;\n    Node *next;\n\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass LinkedList{\nprivate:\n    Node *head;\n\npublic:\n    LinkedList(){\n        head = nullptr;\n    }\n\n    void insertAtEnd(int value){\n        Node * newNode = new Node(value);\n        if(head == nullptr){\n            head = newNode;\n        }\n        else{\n            Node * current = head;\n            while(current->next != nullptr){\n                current = current->next;\n            }\n            current->next = newNode;\n        }\n    }\n\n    void display(){\n        Node * temp = head;\n        while(temp != nullptr){\n            cout << temp->data << \" \";\n            temp = temp->next;\n        }\n        cout << endl;\n    }\n\n    int countAndDeleteOccurrences(int key){\n        int count = 0;\n        \n        // Handle head node occurrences\n        while(head != nullptr && head->data == key){\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n            count++;\n        }\n        \n        // Handle occurrences in the middle and end\n        Node* current = head;\n        while(current != nullptr && current->next != nullptr){\n            if(current->next->data == key){\n                Node* temp = current->next;\n                current->next = current->next->next;\n                delete temp;\n                count++;\n                // DO NOT move current forward, check the new current->next\n            }\n            else{\n                current = current->next;\n            }\n        }\n        return count;\n    }\n};\n\nint main(){\n    LinkedList list;\n    // Input: 5 -> 10 -> 5 -> 20 -> 5\n    list.insertAtEnd(5);\n    list.insertAtEnd(10);\n    list.insertAtEnd(5);\n    list.insertAtEnd(20);\n    list.insertAtEnd(5);\n    cout << \"Original list: \";\n    list.display();\n\n    int key = 5;\n    int occurrences = list.countAndDeleteOccurrences(key);\n    cout << \"Deleted \" << occurrences << \" occurrences of \" << key << endl;\n\n    cout << \"Updated list: \"; // Expected: 10 -> 20\n    list.display();\n\n    return 0;\n}"
    },
    {
      "id": "A5Q3",
      "question": "Write a program to find the middle element of a singly linked list.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass LinkedList {\nprivate:\n    Node* head;\n\npublic:\n    LinkedList() {\n        head = nullptr;\n    }\n\n    void insertAtEnd(int value) {\n        Node* newNode = new Node(value);\n        if (head == nullptr) {\n            head = newNode;\n        } else {\n            Node* current = head;\n            while (current->next != nullptr) {\n                current = current->next;\n            }\n            current->next = newNode;\n        }\n    }\n\n    void display() {\n        Node* temp = head;\n        while (temp != nullptr) {\n            cout << temp->data << \" \";\n            temp = temp->next;\n        }\n        cout << endl;\n    }\n\n    // Uses the Slow and Fast Pointer approach\n    int findMiddle() {\n        if (head == nullptr) return -1; // List is empty\n        Node* slow = head;\n        Node* fast = head;\n        \n        // Fast pointer moves twice as fast as slow pointer.\n        // When fast reaches the end, slow is at the middle.\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow->data;\n    }\n};\n\nint main() {\n    LinkedList list;\n    // List: 10 -> 20 -> 30 -> 40 -> 50 (Odd length)\n    list.insertAtEnd(10);\n    list.insertAtEnd(20);\n    list.insertAtEnd(30);\n    list.insertAtEnd(40);\n    list.insertAtEnd(50);\n\n    cout << \"Linked list: \";\n    list.display();\n\n    int middle = list.findMiddle();\n    cout << \"Middle element: \" << middle << endl; // Expected: 30\n\n    return 0;\n}"
    },
    {
      "id": "A5Q4",
      "question": "Write a program to reverse a singly linked list.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass LinkedList {\nprivate:\n    Node* head;\n\npublic:\n    LinkedList() {\n        head = nullptr;\n    }\n\n    void insertAtEnd(int value) {\n        Node* newNode = new Node(value);\n        if (head == nullptr) {\n            head = newNode;\n        } else {\n            Node* current = head;\n            while (current->next != nullptr) {\n                current = current->next;\n            }\n            current->next = newNode;\n        }\n    }\n\n    void display() {\n        Node* temp = head;\n        while (temp != nullptr) {\n            cout << temp->data << \" \";\n            temp = temp->next;\n        }\n        cout << endl;\n    }\n\n    void reverseList() {\n        Node* prev = nullptr;\n        Node* current = head;\n        Node* nextNode = nullptr;\n        \n        while (current != nullptr) {\n            nextNode = current->next; // Store next node\n            current->next = prev;     // Reverse current node's pointer\n            prev = current;           // Move prev to current node\n            current = nextNode;       // Move current to next node\n        }\n        head = prev; // Update head to the last node (which is now first)\n    }\n};\n\nint main() {\n    LinkedList list;\n    // List: 10 -> 20 -> 30 -> 40 -> 50\n    list.insertAtEnd(10);\n    list.insertAtEnd(20);\n    list.insertAtEnd(30);\n    list.insertAtEnd(40);\n    list.insertAtEnd(50);\n\n    cout << \"Original list: \";\n    list.display();\n\n    list.reverseList();\n    cout << \"Reversed list: \"; // Expected: 50 -> 40 -> 30 -> 20 -> 10\n    list.display();\n\n    return 0;\n}"
    },
    {
      "id": "A5Q_Add1",
      "question": "Find the intersection node of two singly linked lists that merge into a Y-shaped structure.",
      "answer": "#include <iostream>\n#include <cstdlib> // For abs()\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int val) : data(val), next(NULL) {}\n};\n\n// Utility function to get the length of the list\nint getLength(Node* head) {\n    int len = 0;\n    while (head) {\n        len++;\n        head = head->next;\n    }\n    return len;\n}\n\nNode* getIntersectionNode(Node* headA, Node* headB) {\n    int lenA = getLength(headA);\n    int lenB = getLength(headB);\n\n    int diff = abs(lenA - lenB);\n\n    // Advance the longer list's head by the difference in length\n    if (lenA > lenB) while (diff--) headA = headA->next;\n    else while (diff--) headB = headB->next;\n\n    // Traverse both lists together until the nodes match (or reach NULL)\n    while (headA && headB) {\n        if (headA == headB) return headA;\n        headA = headA->next;\n        headB = headB->next;\n    }\n    return NULL;\n}\n\nint main() {\n    // Example: List A: 4 -> 1 -> 8 -> 5\n    //          List B: 5 -> 6 -> 1 -> 8 -> 5 (Intersection at 8)\n    Node* intersectionStart = new Node(8);\n    intersectionStart->next = new Node(5);\n\n    Node* headA = new Node(4);\n    headA->next = new Node(1);\n    headA->next->next = intersectionStart;\n\n    Node* headB = new Node(5);\n    headB->next = new Node(6);\n    headB->next->next = new Node(1);\n    headB->next->next->next = intersectionStart;\n\n    Node* intersection = getIntersectionNode(headA, headB);\n    if (intersection)\n        cout << \"Intersected at \" << intersection->data; // Expected: 8\n    else\n        cout << \"No intersection\";\n        \n    // Clean up memory (omitted for brevity but recommended in production code)\n\n    return 0;\n}"
    },
    {
      "id": "A5Q_Add2",
      "question": "Given a linked list and a positive number K, reverse the nodes in groups of K.",
      "answer": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int x): data(x), next(NULL) {}\n};\n\n// Recursive function to reverse linked list in groups of size k\nNode* reverseK(Node* head, int k) {\n    Node* prev = NULL;\n    Node* curr = head;\n    Node* next = NULL;\n    int count = 0;\n\n    // 1. Reverse the first k nodes\n    while (curr != NULL && count < k) {\n        next = curr->next;\n        curr->next = prev; // Reversing the link\n        prev = curr;\n        curr = next;\n        count++;\n    }\n\n    // 2. 'head' is now the K-th node in the original list (the first node of the next group).\n    // Link the last node of the reversed group (which is now 'head') to the result of\n    // recursively calling the function for the remaining list.\n    if (next != NULL) {\n        head->next = reverseK(next, k);\n    }\n\n    // 3. 'prev' is the new head of the reversed group\n    return prev;\n}\n\nint main() {\n    // List: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9\n    Node* head = new Node(1);\n    Node* temp = head;\n    for (int i = 2; i <= 9; i++) {\n        temp->next = new Node(i);\n        temp = temp->next;\n    }\n\n    int k = 3;\n    head = reverseK(head, k);\n\n    cout << \"Reversed in groups of \" << k << \": \"; // Expected: 3 2 1 6 5 4 9 8 7 \n    while (head) {\n        cout << head->data << \" \";\n        head = head->next;\n    }\n    cout << endl;\n    \n    // Note: The example code in the prompt produced 3 2 1 6 5 4 7 8 9, which happens if the last group (7 8 9) is also reversed. The provided solution matches that behavior.\n\n    return 0;\n}"
    },
    {
      "id": "A5Q_Add3",
      "question": "Given a linked list, remove the loop (cycle) if it exists using the Floyd's Cycle-Finding Algorithm.",
      "answer": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int x): data(x), next(NULL) {}\n};\n\nvoid removeLoop(Node* head) {\n    Node *slow = head, *fast = head;\n    \n    // 1. Detect the loop (Floyd's Cycle-Finding)\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) break; // Loop detected\n    }\n\n    // If the loop was not found\n    if (slow != fast) return; \n\n    // 2. Find the start of the loop\n    slow = head;\n    // Move both slow and fast (which is at the meeting point) one step at a time.\n    // They will meet at the starting node of the loop.\n    while (slow != fast) {\n        slow = slow->next;\n        fast = fast->next;\n    }\n    // Now slow == fast == loop_start_node\n    \n    // 3. Find the node just before the loop start\n    // Move the 'fast' pointer until its next is the loop start node.\n    while (fast->next != slow) {\n        fast = fast->next;\n    }\n    \n    // 4. Remove the loop by setting the next pointer to NULL\n    fast->next = NULL; \n}\n\nint main() {\n    // List: 1 -> 2 -> 3 -> 4 -> 2 (creates loop at 2)\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    Node* loopStart = head->next;\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = loopStart; // creates loop\n\n    removeLoop(head);\n    \n    cout << \"Loop removed successfully! List: \";\n    Node* current = head;\n    while(current) { \n        cout << current->data << \" \"; \n        current = current->next;\n    } // Expected: 1 2 3 4\n    \n    return 0;\n}"
    },
    {
      "id": "A5Q_Add4",
      "question": "Given a linked list and an integer k, rotate the list to the left by k positions.",
      "answer": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int x): data(x), next(NULL) {}\n};\n\nNode* rotateLeft(Node* head, int k) {\n    if (!head || !head->next || k == 0) return head;\n\n    // 1. Find the length and the current tail\n    Node* tail = head;\n    int len = 1;\n    while (tail->next) {\n        tail = tail->next;\n        len++;\n    }\n\n    // Normalize k\n    k = k % len;\n    if (k == 0) return head;\n\n    // 2. Make the list circular: connect old tail to old head\n    tail->next = head; \n\n    // 3. Traverse to the new tail (len - k - 1 steps or k steps from head)\n    // The new tail will be the node k steps from the original head.\n    for (int i = 0; i < k; i++) {\n        tail = tail->next;\n    }\n    \n    // 4. The new head is the node after the new tail\n    head = tail->next;\n    \n    // 5. Break the circular link\n    tail->next = NULL;\n    return head;\n}\n\nint main() {\n    // List: 1 -> 2 -> 3 -> 4 -> 5 -> 6\n    Node* head = new Node(1);\n    Node* temp = head;\n    for (int i = 2; i <= 6; i++) {\n        temp->next = new Node(i);\n        temp = temp->next;\n    }\n\n    int k = 2;\n    head = rotateLeft(head, k);\n    \n    cout << \"Rotated left by \" << k << \": \"; // Expected: 3 4 5 6 1 2\n    while (head) {\n        cout << head->data << \" \";\n        head = head->next;\n    }\n    cout << endl;\n    \n    return 0;\n}"
    },
    {
      "id": "A5Q_Extra1",
      "question": "Write a program to add two polynomials represented by linked lists. Each node should store the coefficient and power of a term.",
      "answer": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int coeff, power;\n    Node* next;\n    Node(int c, int p): coeff(c), power(p), next(NULL) {}\n};\n\nNode* addPolynomials(Node* p1, Node* p2) {\n    // Dummy head for the result list\n    Node* res = new Node(0, 0);\n    Node* temp = res;\n\n    while (p1 && p2) {\n        if (p1->power == p2->power) {\n            // Add coefficients if powers are equal\n            temp->next = new Node(p1->coeff + p2->coeff, p1->power);\n            p1 = p1->next; \n            p2 = p2->next;\n        } else if (p1->power > p2->power) {\n            // Take term from p1 if its power is greater\n            temp->next = new Node(p1->coeff, p1->power);\n            p1 = p1->next;\n        } else { // p2->power > p1->power\n            // Take term from p2 if its power is greater\n            temp->next = new Node(p2->coeff, p2->power);\n            p2 = p2->next;\n        }\n        temp = temp->next;\n    }\n\n    // Append remaining terms from p1 or p2\n    while (p1) { temp->next = new Node(p1->coeff, p1->power); temp = temp->next; p1 = p1->next; }\n    while (p2) { temp->next = new Node(p2->coeff, p2->power); temp = temp->next; p2 = p2->next; }\n\n    // Return the actual head of the result list\n    Node* resultHead = res->next;\n    delete res;\n    return resultHead;\n}\n\nint main() {\n    // Poly1: 5x^2 + 4x^1 + 2x^0\n    Node* poly1 = new Node(5, 2);\n    poly1->next = new Node(4, 1);\n    poly1->next->next = new Node(2, 0);\n\n    // Poly2: 5x^1 + 5x^0\n    Node* poly2 = new Node(5, 1);\n    poly2->next = new Node(5, 0);\n\n    Node* res = addPolynomials(poly1, poly2);\n    cout << \"Result Polynomial: \";\n    // Expected: 5x^2 + 9x^1 + 7x^0\n    while (res) {\n        cout << res->coeff << \"x^\" << res->power << (res->next ? \" + \" : \"\");\n        res = res->next;\n    }\n    cout << endl;\n    \n    return 0;\n}"
    },
    {
      "id": "A6Add1",
      "question": "Split a Circular Linked List into two halves. If the number of nodes is odd, the extra node should go to the first list.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node{\npublic:\n    int data;\n    Node * next;\n\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass CircularLinkedList{\npublic:\n    Node *head;\n\n    CircularLinkedList(){\n        head = nullptr;\n    }\n\n    void insertAtBegin(int num){\n        Node *newNode = new Node(num);\n        if(!head){\n            head = newNode;\n            newNode->next = head; \n        }\n        else{\n            Node *current = head;\n            while(current->next != head){\n                current = current->next;\n            }\n            current->next = newNode;\n            newNode->next = head;\n            head = newNode;\n        }\n    }\n\n    void insertAtEnd(int num){\n        Node *newNode = new Node(num);\n        if(!head){\n            head = newNode;\n            newNode->next = head;\n        }\n        else{\n            Node *current = head;\n            while(current->next != head){\n                current = current->next;\n            }\n            current->next = newNode;\n            newNode->next = head;\n        }\n    }\n\n    void deleteAtBegin(){\n        if(!head){\n            cout << \"Linked list is empty, Nothing to delete!\";\n        }\n        else{\n            Node *temp = head;\n            if(head->next == head){\n                head = nullptr;\n            }\n            else{\n                Node *current = head;\n                while(current->next != head){\n                    current = current->next;\n                }\n                head = head->next;\n                current->next = head;\n            }\n            delete temp;\n        }\n    }\n\n    void deleteAtEnd(){\n        if(!head){\n            cout << \"Linked list is Empty, Nothing to delete!\";\n        }\n        else{\n            Node *temp = head;\n            if(head->next == head){\n                head = nullptr;\n            }\n            else{\n                Node *current = head;\n                Node *prev = nullptr;\n                while(current->next != head){\n                    prev = current;\n                    current = current->next;\n                }\n                prev->next = head;\n            }\n            delete temp;\n        }\n    }\n\n    bool search(int value){\n        if(!head){\n            cout << \"Linked list is Empty, No element to search!\";\n            return false;\n        }\n        else{\n            Node *temp = head;\n            do{\n                if(temp->data == value){\n                    cout << \"Element found!\" << endl;\n                    return true;\n                }\n                temp = temp->next;\n            }while(temp != head);\n\n            cout << \"Element not found!\";\n            return false;\n        }\n    }\n\n    void display(){\n        if(!head){\n            cout << \"Linked list is empty, No elements to display!\";\n        }\n        else{\n            Node *temp = head;\n            do{\n                cout << temp->data << \" \";\n                temp = temp->next;\n            }while(temp != head);\n            cout << endl;\n        }\n    }\n\n    int get_size(){\n        int size = 1;\n        if(head == nullptr){\n            return 0;\n        }\n        else{\n            Node* temp = head;\n            while(temp->next != head){\n                size++;\n                temp = temp->next;\n            }\n            return size;\n        }\n    }\n};\n\nvoid splitLinkedList(CircularLinkedList &C, CircularLinkedList &C1, CircularLinkedList &C2){\n        int size = C.get_size();\n        if (size % 2 == 0 ){\n            Node* temp = C.head;\n            for(int i = 1; i <= size / 2; i++){\n                C1.insertAtEnd(temp->data);\n                temp = temp->next;\n            }\n            for(int i = 1; i <= size / 2; i++){\n                C2.insertAtEnd(temp->data);\n                temp = temp->next;\n            }\n        }\n        else{\n            Node* temp1 = C.head;\n            for(int i = 1; i <= (size / 2) + 1; i++){\n                C1.insertAtEnd(temp1->data);\n                temp1 = temp1->next;\n            }\n            for(int i = (size / 2) + 1; i < size; i++){\n                C2.insertAtEnd(temp1->data);\n                temp1 = temp1->next;\n            }\n        }    \n}\n\nint main(){\n    CircularLinkedList C,C1,C2;\n\n    C.insertAtBegin(3);\n    C.insertAtBegin(4);\n    C.insertAtBegin(6);\n    C.insertAtBegin(7);\n    C.insertAtBegin(8);\n\n    C.display();\n\n    splitLinkedList(C, C1, C2);\n    \n    C1.display();\n    C2.display();\n    return 0;\n}"
    },
    {
      "id": "A6Add3",
      "question": "Given a Doubly linked list containing n nodes, reverse every group of k nodes in the list.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node* prev;\n\n    Node(int val) {\n        data = val;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\nNode* reverseInGroups(Node* head, int k) {\n    if (!head) return nullptr;\n\n    Node* current = head;\n    Node* next = nullptr;\n    Node* prevNode = nullptr;\n    int count = 0;\n\n    while (current != nullptr && count < k) {\n        next = current->next;\n        current->next = prevNode;\n        current->prev = next;\n        prevNode = current;\n        current = next;\n        count++;\n    }\n\n    if (next != nullptr) {\n        head->next = reverseInGroups(next, k);\n        if (head->next)\n            head->next->prev = head;\n    }\n\n    return prevNode;\n}\n\nvoid insert(Node*& head, int data) {\n    Node* newNode = new Node(data);\n    if (head == nullptr) {\n        head = newNode;\n        return;\n    }\n    Node* temp = head;\n    while (temp->next != nullptr)\n        temp = temp->next;\n    temp->next = newNode;\n    newNode->prev = temp;\n}\n\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout << temp->data << \" \";\n        temp = temp->next;\n    }\n    cout << endl;\n}\n\nint main() {\n    Node* head = nullptr;\n\n    for (int i = 1; i <= 8; i++)\n        insert(head, i);\n\n    cout << \"Original list: \";\n    printList(head);\n\n    int k = 3;\n    head = reverseInGroups(head, k);\n\n    cout << \"Reversed in groups of \" << k << \": \";\n    printList(head);\n\n    return 0;\n}"
    },
    {
      "id": "A6Add4",
      "question": "Given a doubly linked list having exactly one of the node pointing to a random node in the list, correct this random pointer so it points to the expected node (itself, in this specific logic, or correcting a structure where random points incorrectly).",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node* prev;\n    Node* random;\n\n    Node(int val) {\n        data = val;\n        next = prev = random = nullptr;\n    }\n};\n\nvoid correctRandomPointer(Node* head) {\n    Node* temp = head;\n    while (temp) {\n        if (temp->random && temp->random->next == temp) {\n            temp->random = temp->next;\n            break;\n        }\n        temp = temp->next;\n    }\n}\n\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp) {\n        cout << temp->data;\n        if (temp->random)\n            cout << \" (Random -> \" << temp->random->data << \")\";\n        cout << \"  \";\n        temp = temp->next;\n    }\n    cout << endl;\n}\n\nint main() {\n    Node* head = new Node(1);\n    Node* second = new Node(2);\n    Node* third = new Node(3);\n    Node* fourth = new Node(4);\n\n    head->next = second;\n    second->prev = head;\n    second->next = third;\n    third->prev = second;\n    third->next = fourth;\n    fourth->prev = third;\n\n    third->random = second;\n\n    cout << \"Before correction: \";\n    printList(head);\n\n    correctRandomPointer(head);\n\n    cout << \"After correction: \";\n    printList(head);\n\n    return 0;\n}"
    },
    {
      "id": "A6Add5",
      "question": "Construct a 2D Grid using a Doubly Linked List (Quadruply Linked List) from a 2D Matrix.",
      "answer": "#include <iostream>\n#include <vector>\n\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* prev;\n    Node* up;\n    Node* down;\n\n    Node(int v) : val(v), next(nullptr), prev(nullptr), up(nullptr), down(nullptr) {}\n};\n\nclass GridDLL {\npublic:\n    GridDLL(const std::vector<std::vector<int>>& mat) {\n        if (mat.empty() || mat[0].empty()) {\n            rows = cols = 0;\n            head = nullptr;\n            return;\n        }\n\n        rows = static_cast<int>(mat.size());\n        cols = static_cast<int>(mat[0].size());\n\n        nodes.assign(rows, std::vector<Node*>(cols, nullptr));\n\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < cols; ++j)\n                nodes[i][j] = new Node(mat[i][j]);\n\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < cols; ++j) {\n                if (j + 1 < cols) {\n                    nodes[i][j]->next = nodes[i][j+1];\n                    nodes[i][j+1]->prev = nodes[i][j];\n                }\n                if (i + 1 < rows) {\n                    nodes[i][j]->down = nodes[i+1][j];\n                    nodes[i+1][j]->up = nodes[i][j];\n                }\n            }\n\n        head = nodes[0][0];\n    }\n\n    ~GridDLL() {\n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < cols; ++j)\n                delete nodes[i][j];\n    }\n\n    Node* getHead() const { return head; }\n\n    void printRowMajor() const {\n        for (int i = 0; i < rows; ++i) {\n            Node* cur = nodes[i][0];\n            for (int j = 0; j < cols; ++j) {\n                std::cout << cur->val << (j + 1 < cols ? ' ' : '\\n');\n                cur = cur->next;\n            }\n        }\n    }\n\n    void printColumnMajor() const {\n        for (int j = 0; j < cols; ++j) {\n            Node* cur = nodes[0][j];\n            for (int i = 0; i < rows; ++i) {\n                std::cout << cur->val << (i + 1 < rows ? ' ' : '\\n');\n                cur = cur->down;\n            }\n        }\n    }\n\nprivate:\n    int rows = 0, cols = 0;\n    std::vector<std::vector<Node*>> nodes;\n    Node* head = nullptr;\n};\n\nint main() {\n    std::vector<std::vector<int>> mat = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    GridDLL grid(mat);\n\n    Node* head = grid.getHead();\n    if (head) {\n        std::cout << \"Head value: \" << head->val << \"\\n\";\n        std::cout << \"Row-major traversal:\\n\";\n        grid.printRowMajor();\n        std::cout << \"Column-major traversal:\\n\";\n        grid.printColumnMajor();\n    } else {\n        std::cout << \"Empty grid.\\n\";\n    }\n\n    return 0;\n}"
    },
    {
      "id": "A6Q1_DLL",
      "question": "Develop a menu driven program for Doubly Linked List operations: Insertion, Deletion, Search, and Size.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node{\npublic:\n    int data;\n    Node *next, *prev;\n\n    Node(int data){\n        this->data = data;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\nclass DLL_implementation{\nprivate:\n    Node *head;\n\npublic:\n    DLL_implementation(){\n        head = nullptr;\n    }\n\n    void insertatBeg(int value){\n        Node* newNode = new Node(value);\n        if(head == nullptr){\n            head = newNode;\n        }\n        else{\n            newNode->next = head;\n            head->prev = newNode;\n            head = newNode;\n        }\n    }\n\n    void insertatEnd(int value){\n        Node* newNode = new Node(value);\n        if(head == nullptr){\n            head = newNode;\n        }\n        else{\n            Node* temp = head;\n            while(temp->next != nullptr){\n                temp = temp->next;\n            }\n            temp->next = newNode;\n            newNode->prev = temp;\n        }\n    }\n\n    void insertatspecificvalue(int newValue, int existingValue){\n        Node* newNode = new Node(newValue);\n        Node* temp = head;\n        while(temp != nullptr && temp->data != existingValue){\n            temp = temp->next;\n        }\n        if(temp == nullptr){\n            cout << \"The given value is not present in the Linked list!\";\n        }\n        else if(temp->next == nullptr){\n            temp->next = newNode;\n            newNode->prev = temp;\n        }\n        else{\n            newNode->next = temp->next;\n            newNode->prev = temp;\n            temp->next->prev = newNode;\n            temp->next = newNode;\n        }\n    }\n\n    void delatSpecificNode(int existingvalue){\n        Node* temp = head;\n        while(temp != nullptr && temp->data != existingvalue){\n            temp = temp->next;\n        }\n        if(temp == nullptr){\n            cout << \"Value not found!\";\n        }\n        else if(temp == head && temp->next == nullptr){\n            head = nullptr;\n        }\n        else if(temp->next == nullptr){\n            temp->prev->next = nullptr;\n        }\n        \n        else{\n            temp->prev->next = temp->next;\n            temp->next->prev = temp->prev;\n        }\n        delete(temp);\n    }\n\n    void search(int value){\n        if(head == nullptr){\n            cout << \"Linked list is empty!\";\n        }\n\n        Node* temp = head;\n\n        while(temp != nullptr && temp->data != value){\n            temp = temp->next;\n        }\n        if(temp->data == value){\n            cout << \"Element found in the Linked list!\";\n        }\n        else{\n            cout << \"Element not found in the Linked list!\";\n        }\n    }\n\n    int get_size(){\n        int size = 0;\n        if(head == nullptr){\n            return 0;\n        }\n        else{\n            Node* temp = head;\n            while(temp!=nullptr){\n                size++;\n                temp = temp->next;\n            }\n            return size;\n        }\n    }\n};\n\nint main(){\n    DLL_implementation DLL1;\n    DLL1.insertatBeg(6);\n    DLL1.insertatBeg(5);\n    DLL1.insertatBeg(4);\n    DLL1.insertatBeg(3);\n\n    DLL1.search(4);\n    cout << endl;\n    cout << \"The size of the Linked list is: \"<< DLL1.get_size() << endl;\n    \n}"
    },
    {
      "id": "A6Q2_CLL",
      "question": "Display all the node values in a circular linked list, repeating value of head node at the end.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node{\npublic:\n    int data;\n    Node * next;\n\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass CircularLinkedList{\nprivate:\n    Node *head;\n\npublic:\n    CircularLinkedList(){\n        head = nullptr;\n    }\n\n    void insertAtBegin(int num){\n        Node *newNode = new Node(num);\n        if(!head){\n            head = newNode;\n            newNode->next = head; \n        }\n        else{\n            Node *current = head;\n            while(current->next != head){\n                current = current->next;\n            }\n            current->next = newNode;\n            newNode->next = head;\n            head = newNode;\n        }\n    }\n\n    void insertAtEnd(int num){\n        Node *newNode = new Node(num);\n        if(!head){\n            head = newNode;\n            newNode->next = head;\n        }\n        else{\n            Node *current = head;\n            while(current->next != head){\n                current = current->next;\n            }\n            current->next = newNode;\n            newNode->next = head;\n        }\n    }\n\n    void deleteAtBegin(){\n        if(!head){\n            cout << \"Linked list is empty, Nothing to delete!\";\n        }\n        else{\n            Node *temp = head;\n            if(head->next == head){\n                head = nullptr;\n            }\n            else{\n                Node *current = head;\n                while(current->next != head){\n                    current = current->next;\n                }\n                head = head->next;\n                current->next = head;\n            }\n            delete temp;\n        }\n    }\n\n    void deleteAtEnd(){\n        if(!head){\n            cout << \"Linked list is Empty, Nothing to delete!\";\n        }\n        else{\n            Node *temp = head;\n            if(head->next == head){\n                head = nullptr;\n            }\n            else{\n                Node *current = head;\n                Node *prev = nullptr;\n                while(current->next != head){\n                    prev = current;\n                    current = current->next;\n                }\n                prev->next = head;\n            }\n            delete temp;\n        }\n    }\n\n    bool search(int value){\n        if(!head){\n            cout << \"Linked list is Empty, No element to search!\";\n            return false;\n        }\n        else{\n            Node *temp = head;\n            do{\n                if(temp->data == value){\n                    cout << \"Element found!\" << endl;\n                    return true;\n                }\n                temp = temp->next;\n            }while(temp != head);\n\n            cout << \"Element not found!\";\n            return false;\n        }\n    }\n\n    void display(){\n        if(!head){\n            cout << \"Linked list is empty, No elements to display!\";\n        }\n        else{\n            Node *temp = head;\n            do{\n                cout << temp->data << \" \";\n                temp = temp->next;\n            }while(temp != head);\n            cout << head->data << endl;\n        }\n    }\n\n    int get_size(){\n        int size = 1;\n        if(head == nullptr){\n            return 0;\n        }\n        else{\n            Node* temp = head;\n            while(temp->next != head){\n                size++;\n                temp = temp->next;\n            }\n            return size;\n        }\n    }\n};\n\nint main(){\n    CircularLinkedList C;\n\n    C.insertAtBegin(3);\n    C.insertAtBegin(4);\n    C.insertAtBegin(5);\n    C.insertAtBegin(6);\n    C.insertAtBegin(8);\n\n\n    C.display();\n    cout << endl;\n\n    cout << \"The size of the Circluar linked list is: \" << C.get_size() << endl;\n    return 0;\n}"
    },
    {
      "id": "A6Q4",
      "question": "Write a program to check if a doubly linked list of characters is palindrome or not.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node{\npublic:\n    int data;\n    Node *next, *prev;\n\n    Node(int data){\n        this->data = data;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\nclass DLL_implementation{\nprivate:\n    Node *head;\n\npublic:\n    DLL_implementation(){\n        head = nullptr;\n    }\n\n    void insertatBeg(int value){\n        Node* newNode = new Node(value);\n        if(head == nullptr){\n            head = newNode;\n        }\n        else{\n            newNode->next = head;\n            head->prev = newNode;\n            head = newNode;\n        }\n    }\n\n    void insertatEnd(int value){\n        Node* newNode = new Node(value);\n        if(head == nullptr){\n            head = newNode;\n        }\n        else{\n            Node* temp = head;\n            while(temp->next != nullptr){\n                temp = temp->next;\n            }\n            temp->next = newNode;\n            newNode->prev = temp;\n        }\n    }\n\n    void insertatspecificvalue(int newValue, int existingValue){\n        Node* newNode = new Node(newValue);\n        Node* temp = head;\n        while(temp != nullptr && temp->data != existingValue){\n            temp = temp->next;\n        }\n        if(temp == nullptr){\n            cout << \"The given value is not present in the Linked list!\";\n        }\n        else if(temp->next == nullptr){\n            temp->next = newNode;\n            newNode->prev = temp;\n        }\n        else{\n            newNode->next = temp->next;\n            newNode->prev = temp;\n            temp->next->prev = newNode;\n            temp->next = newNode;\n        }\n    }\n\n    void delatSpecificNode(int existingvalue){\n        Node* temp = head;\n        while(temp != nullptr && temp->data != existingvalue){\n            temp = temp->next;\n        }\n        if(temp == nullptr){\n            cout << \"Value not found!\";\n        }\n        else if(temp == head && temp->next == nullptr){\n            head = nullptr;\n        }\n        else if(temp->next == nullptr){\n            temp->prev->next = nullptr;\n        }\n        \n        else{\n            temp->prev->next = temp->next;\n            temp->next->prev = temp->prev;\n        }\n        delete(temp);\n    }\n\n    void search(int value){\n        if(head == nullptr){\n            cout << \"Linked list is empty!\";\n        }\n\n        Node* temp = head;\n\n        while(temp != nullptr && temp->data != value){\n            temp = temp->next;\n        }\n        if(temp->data == value){\n            cout << \"Element found in the Linked list!\";\n        }\n        else{\n            cout << \"Element not found in the Linked list!\";\n        }\n    }\n\n    bool check_palindrome(){\n        if(head == nullptr || head->next == nullptr){\n            return true;\n        }\n\n        Node* left = head;\n        Node* right = head;\n\n        while(right->next != nullptr){\n            right = right->next;\n        }\n\n        while(left != right && left->prev != right){\n            if(left->data == right->data){\n                left = left->next;\n                right = right->prev;\n            }\n            else{\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main(){\n    DLL_implementation DLL1;\n    DLL1.insertatBeg(6);\n    DLL1.insertatBeg(5);\n    DLL1.insertatBeg(5);\n    DLL1.insertatBeg(6);\n    \n    if(DLL1.check_palindrome()){\n        cout << \"The Linked list contains a palindrome number!\";\n    }\n    else{\n        cout << \"The Linked list does not contain a palindrome number!\";\n    }\n}"
    },
    {
      "id": "A6Q5",
      "question": "Write a program to check if a linked list is Circular Linked List or not.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node{\npublic:\n    int data;\n    Node * next;\n\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass CircularLinkedList{\nprivate:\n    Node *head;\n\npublic:\n    CircularLinkedList(){\n        head = nullptr;\n    }\n\n    void insertAtBegin(int num){\n        Node *newNode = new Node(num);\n        if(!head){\n            head = newNode;\n            newNode->next = head; \n        }\n        else{\n            Node *current = head;\n            while(current->next != head){\n                current = current->next;\n            }\n            current->next = newNode;\n            newNode->next = head;\n            head = newNode;\n        }\n    }\n\n    void insertAtEnd(int num){\n        Node *newNode = new Node(num);\n        if(!head){\n            head = newNode;\n            newNode->next = head;\n        }\n        else{\n            Node *current = head;\n            while(current->next != head){\n                current = current->next;\n            }\n            current->next = newNode;\n            newNode->next = head;\n        }\n    }\n\n    void deleteAtBegin(){\n        if(!head){\n            cout << \"Linked list is empty, Nothing to delete!\";\n        }\n        else{\n            Node *temp = head;\n            if(head->next == head){\n                head = nullptr;\n            }\n            else{\n                Node *current = head;\n                while(current->next != head){\n                    current = current->next;\n                }\n                head = head->next;\n                current->next = head;\n            }\n            delete temp;\n        }\n    }\n\n    void deleteAtEnd(){\n        if(!head){\n            cout << \"Linked list is Empty, Nothing to delete!\";\n        }\n        else{\n            Node *temp = head;\n            if(head->next == head){\n                head = nullptr;\n            }\n            else{\n                Node *current = head;\n                Node *prev = nullptr;\n                while(current->next != head){\n                    prev = current;\n                    current = current->next;\n                }\n                prev->next = head;\n            }\n            delete temp;\n        }\n    }\n\n    bool search(int value){\n        if(!head){\n            cout << \"Linked list is Empty, No element to search!\";\n            return false;\n        }\n        else{\n            Node *temp = head;\n            do{\n                if(temp->data == value){\n                    cout << \"Element found!\" << endl;\n                    return true;\n                }\n                temp = temp->next;\n            }while(temp != head);\n\n            cout << \"Element not found!\";\n            return false;\n        }\n    }\n\n    void display(){\n        if(!head){\n            cout << \"Linked list is empty, No elements to display!\";\n        }\n        else{\n            Node *temp = head;\n            do{\n                cout << temp->data << \" \";\n                temp = temp->next;\n            }while(temp != head);\n            cout << endl;\n        }\n    }\n\n    void check_LL(){\n        Node* temp = head;\n        while(temp->next != nullptr && temp->next != head){\n            temp = temp->next;\n        }\n        if(temp->next == nullptr){\n            cout << \"The given Linked list is a singly linked list!\";\n        }\n        else{\n            cout << \"The given Linked list is a Circular linked list!\";\n        }\n    }\n\n};\nint main(){\n    CircularLinkedList C;\n\n    C.insertAtBegin(3);\n    C.insertAtBegin(4);\n    C.insertAtBegin(5);\n    C.insertAtBegin(6);\n    C.insertAtBegin(8);\n\n    C.display();\n\n    C.check_LL();\n\n    return 0;\n}"
    },
    {
      "id": "A6Add2",
      "question": "Delete all nodes from a Circular Linked List that have even parity.",
      "answer": "#include <iostream>\nusing namespace std;\n\nint get_parity(int n);\n\nclass Node{\npublic:\n    int data;\n    Node * next;\n\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass CircularLinkedList{\nprivate:\n    Node *head;\n\npublic:\n    CircularLinkedList(){\n        head = nullptr;\n    }\n\n    void insertAtBegin(int num){\n        Node *newNode = new Node(num);\n        if(!head){\n            head = newNode;\n            newNode->next = head; \n        }\n        else{\n            Node *current = head;\n            while(current->next != head){\n                current = current->next;\n            }\n            current->next = newNode;\n            newNode->next = head;\n            head = newNode;\n        }\n    }\n\n    void insertAtEnd(int num){\n        Node *newNode = new Node(num);\n        if(!head){\n            head = newNode;\n            newNode->next = head;\n        }\n        else{\n            Node *current = head;\n            while(current->next != head){\n                current = current->next;\n            }\n            current->next = newNode;\n            newNode->next = head;\n        }\n    }\n\n    void deleteAtBegin(){\n        if(!head){\n            cout << \"Linked list is empty, Nothing to delete!\";\n        }\n        else{\n            Node *temp = head;\n            if(head->next == head){\n                head = nullptr;\n            }\n            else{\n                Node *current = head;\n                while(current->next != head){\n                    current = current->next;\n                }\n                head = head->next;\n                current->next = head;\n            }\n            delete temp;\n        }\n    }\n\n    void deleteAtEnd(){\n        if(!head){\n            cout << \"Linked list is Empty, Nothing to delete!\";\n        }\n        else{\n            Node *temp = head;\n            if(head->next == head){\n                head = nullptr;\n            }\n            else{\n                Node *current = head;\n                Node *prev = nullptr;\n                while(current->next != head){\n                    prev = current;\n                    current = current->next;\n                }\n                prev->next = head;\n            }\n            delete temp;\n        }\n    }\n\n    void deleteSpecificNode(int existingvalue){\n        if(head == nullptr){\n            cout << \"Linked list is empty! Nothing to delete!\";\n        }\n        else{\n            Node* temp = head;\n            Node* prev = nullptr;\n            while(temp->next != head && temp->data != existingvalue){\n                prev = temp;\n                temp = temp->next;\n            }\n            if(temp == head){\n                deleteAtBegin();\n            }\n            else if(temp->next == head){\n                deleteAtEnd();\n            }\n            else{\n                prev->next = temp->next;\n            }\n            delete(temp);\n        }\n    }\n\n    bool search(int value){\n        if(!head){\n            cout << \"Linked list is Empty, No element to search!\";\n            return false;\n        }\n        else{\n            Node *temp = head;\n            do{\n                if(temp->data == value){\n                    cout << \"Element found!\" << endl;\n                    return true;\n                }\n                temp = temp->next;\n            }while(temp != head);\n\n            cout << \"Element not found!\";\n            return false;\n        }\n    }\n\n    void display(){\n        if(!head){\n            cout << \"Linked list is empty, No elements to display!\";\n        }\n        else{\n            Node *temp = head;\n            do{\n                cout << temp->data << \" \";\n                temp = temp->next;\n            }while(temp != head);\n            cout << endl;\n        }\n    }\n\n    int get_size(){\n        int size = 1;\n        if(head == nullptr){\n            return 0;\n        }\n        else{\n            Node* temp = head;\n            while(temp->next != head){\n                size++;\n                temp = temp->next;\n            }\n            return size;\n        }\n    }\n\n    void deleteAtevenParity(){\n        if(head == nullptr){\n            cout << \"Linked List is empty! Nothing to delete.\";\n        }\n        else{\n            Node* temp = head;\n            while(temp->next != head){\n                Node* nextNode = temp->next;\n                int parity = get_parity(temp->data);\n                if(parity % 2 == 0){\n                    deleteSpecificNode(temp->data);\n                }\n                temp = nextNode;\n            }\n        }\n    }\n};\n\nint get_parity(int n){\n    string binary = \"\";\n    while(n > 0){\n        binary = to_string(n % 2) + binary;\n        n /= 2;\n    }\n\n    int count = 0;\n    for(int i = 0; i < binary.length(); i++){\n        if(binary[i] == '1'){\n            count++;\n        }\n    }\n    return count;\n}\n\nint main(){\n    CircularLinkedList CLL1;\n    CLL1.insertAtBegin(7);\n    CLL1.insertAtBegin(5);\n    CLL1.insertAtBegin(8);\n    CLL1.insertAtBegin(13);\n    CLL1.insertAtBegin(15);\n\n    CLL1.display();\n\n    CLL1.deleteAtevenParity();\n\n    CLL1.display();\n}"
    },
    {
      "id": "A6Q1_DeleteSpecific",
      "question": "Delete a specific node from a Doubly Linked List.",
      "answer": "#include <iostream>\nusing namespace std;\n\nint get_parity(int n);\n\nclass Node{\npublic:\n    int data;\n    Node *next, *prev;\n\n    Node(int data){\n        this->data = data;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\nclass DLL_implementation{\nprivate:\n    Node *head;\n\npublic:\n    DLL_implementation(){\n        head = nullptr;\n    }\n\n    void insertatBeg(int value){\n        Node* newNode = new Node(value);\n        if(head == nullptr){\n            head = newNode;\n        }\n        else{\n            newNode->next = head;\n            head->prev = newNode;\n            head = newNode;\n        }\n    }\n\n    void insertatEnd(int value){\n        Node* newNode = new Node(value);\n        if(head == nullptr){\n            head = newNode;\n        }\n        else{\n            Node* temp = head;\n            while(temp->next != nullptr){\n                temp = temp->next;\n            }\n            temp->next = newNode;\n            newNode->prev = temp;\n        }\n    }\n\n    void insertatspecificvalue(int newValue, int existingValue){\n        Node* newNode = new Node(newValue);\n        Node* temp = head;\n        while(temp != nullptr && temp->data != existingValue){\n            temp = temp->next;\n        }\n        if(temp == nullptr){\n            cout << \"The given value is not present in the Linked list!\";\n        }\n        else if(temp->next == nullptr){\n            temp->next = newNode;\n            newNode->prev = temp;\n        }\n        else{\n            newNode->next = temp->next;\n            newNode->prev = temp;\n            temp->next->prev = newNode;\n            temp->next = newNode;\n        }\n    }\n\n    void deleteSpecificNode(int existingvalue){\n        Node* temp = head;\n        while(temp != nullptr && temp->data != existingvalue){\n            temp = temp->next;\n        }\n        if(temp == nullptr){\n            cout << \"Value not found!\";\n        }\n        else if(temp == head) { \n            head = head->next;\n            head->prev = nullptr;\n            temp->next = nullptr; \n        }\n\n        else if(temp->next == nullptr){\n            temp->prev->next = nullptr;\n        }\n        \n        else{\n            temp->prev->next = temp->next;\n            temp->next->prev = temp->prev;\n        }\n        delete(temp);\n    }\n\n    void search(int value){\n        if(head == nullptr){\n            cout << \"Linked list is empty!\";\n        }\n\n        Node* temp = head;\n\n        while(temp != nullptr && temp->data != value){\n            temp = temp->next;\n        }\n        if(temp->data == value){\n            cout << \"Element found in the Linked list!\";\n        }\n        else{\n            cout << \"Element not found in the Linked list!\";\n        }\n    }\n\n    int get_size(){\n        int size = 0;\n        if(head == nullptr){\n            return 0;\n        }\n        else{\n            Node* temp = head;\n            while(temp!=nullptr){\n                size++;\n                temp = temp->next;\n            }\n            return size;\n        }\n    }\n\n    void display(){\n        if(head == nullptr){\n            cout << \"Linked list is empty nothing to display!\";\n        }\n        else{\n            Node *temp = head;\n            while(temp != nullptr){\n                cout << temp->data << \" \";\n                temp = temp->next;\n            }\n        }\n    }\n};\n\nint main(){\n    DLL_implementation DLL1;\n    DLL1.insertatBeg(6);\n    DLL1.insertatBeg(5);\n    DLL1.insertatBeg(4);\n    DLL1.insertatBeg(3);\n\n    DLL1.display();\n    cout << endl;\n    DLL1.deleteSpecificNode(6);\n    cout << endl;\n    DLL1.display();\n}"
    },
    {
      "id": "A8Q1_3",
      "question": "Write a program for Binary Search Tree (BST) having functions for: 1. Traversals (Pre-order, In-order, Post-order). 2. Insert an element. 3. Delete an element. 4. Maximum depth. 5. Minimum depth.",
      "answer": "#include <iostream>\n#include <algorithm> // for std::max, std::min\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node *lchild;\n    Node *rchild;\n\n    Node(int data) {\n        this->data = data;\n        lchild = nullptr;\n        rchild = nullptr;\n    }\n};\n\nclass BST_implementation {\npublic:\n    Node *root;\n\n    BST_implementation() {\n        root = nullptr;\n    }\n\n    void insert_unique_element(int value) {\n        Node *newNode = new Node(value);\n\n        if (root == nullptr) {\n            root = newNode;\n            return;\n        }\n\n        Node *current = root;\n        Node *parent = nullptr;\n\n        while (current != nullptr) {\n            parent = current;\n\n            if (value < current->data)\n                current = current->lchild;\n            else if (value > current->data)\n                current = current->rchild;\n            else {\n                cout << \"Same values cannot be inserted in the BST!\" << endl;\n                delete newNode;\n                return;\n            }\n        }\n\n        if (value > parent->data)\n            parent->rchild = newNode;\n        else\n            parent->lchild = newNode;\n    }\n\n    Node* min_node(Node* node) {\n        Node* current = node;\n        while (current && current->lchild != nullptr)\n            current = current->lchild;\n        return current;\n    }\n\n    Node* deleteElement(Node* root, int value) {\n        if (root == nullptr)\n            return root;\n\n        if (value < root->data)\n            root->lchild = deleteElement(root->lchild, value);\n        else if (value > root->data)\n            root->rchild = deleteElement(root->rchild, value);\n        else {\n            if (root->lchild == nullptr) {\n                Node* temp = root->rchild;\n                delete root;\n                return temp;\n            } else if (root->rchild == nullptr) {\n                Node* temp = root->lchild;\n                delete root;\n                return temp;\n            }\n\n            Node* temp = min_node(root->rchild);\n            root->data = temp->data;\n            root->rchild = deleteElement(root->rchild, temp->data);\n        }\n        return root;\n    }\n\n    int maxDepth(Node *root){\n        if (root == nullptr) {              \n            return 0;\n        }\n        int L = maxDepth(root->lchild);\n        int R = maxDepth(root->rchild);\n        return 1 + std::max(L, R);\n    }\n\n    int minDepth(Node* root){\n        if (root == nullptr) {              \n            return 0;\n        }\n        if (root->lchild == nullptr && root->rchild == nullptr){\n            return 1;\n        }\n        if (root->lchild == nullptr){\n            return 1 + minDepth(root->rchild);\n        }\n        if (root->rchild == nullptr){\n            return 1 + minDepth(root->lchild);\n        }\n\n        return 1 + std::min(minDepth(root->lchild), minDepth(root->rchild));\n    }\n\n    void inorder_traversal(Node* root){\n        if(root != nullptr){\n            inorder_traversal(root->lchild);\n            cout << root->data << \" \";\n            inorder_traversal(root->rchild);\n        }\n    }\n\n    void preorder_traversal(Node* root){\n        if(root != nullptr){\n            cout << root->data << \" \";\n            preorder_traversal(root->lchild);\n            preorder_traversal(root->rchild);\n        }\n    }\n\n    void postorder_traversal(Node* root){\n        if(root != nullptr){\n            postorder_traversal(root->lchild);\n            postorder_traversal(root->rchild);\n            cout << root->data << \" \";\n        }\n    }\n\n};\n\nint main() {\n    BST_implementation B1;\n\n    B1.insert_unique_element(4);\n    B1.insert_unique_element(2);\n    B1.insert_unique_element(6);\n    B1.insert_unique_element(1);\n    B1.insert_unique_element(3);\n    B1.insert_unique_element(5);\n    B1.insert_unique_element(7);\n\n    B1.root = B1.deleteElement(B1.root, 4);\n\n    cout << \"Max depth: \" << B1.maxDepth(B1.root) << '\\n';\n    cout << \"Min depth: \" << B1.minDepth(B1.root) << '\\n';\n\n    B1.inorder_traversal(B1.root);\n    cout << endl;\n    B1.preorder_traversal(B1.root);\n    cout << endl;\n    B1.postorder_traversal(B1.root);\n\n    return 0;\n}"
    },
    {
      "id": "A8Q2_4",
      "question": "Implement functions for Binary Search Trees: (a) Search (Recursive & Iterative), (b) Maximum/Minimum element, (c) In-order successor/predecessor, (d) Check if a tree is a BST.",
      "answer": "#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node *lchild;\n    Node *rchild;\n\n    Node(int data) {\n        this->data = data;\n        lchild = nullptr;\n        rchild = nullptr;\n    }\n};\n\nclass BST_implementation {\npublic:\n    Node *root;\n\n    BST_implementation() {\n        root = nullptr;\n    }\n\n    void insert_unique_element(int value) {\n        Node *newNode = new Node(value);\n\n        if (root == nullptr) {\n            root = newNode;\n            return;\n        }\n\n        Node *current = root;\n        Node *parent = nullptr;\n\n        while (current != nullptr) {\n            parent = current;\n\n            if (value < current->data)\n                current = current->lchild;\n            else if (value > current->data)\n                current = current->rchild;\n            else {\n                cout << \"Same values cannot be inserted in the BST!\" << endl;\n                delete newNode;\n                return;\n            }\n        }\n\n        if (value > parent->data)\n            parent->rchild = newNode;\n        else\n            parent->lchild = newNode;\n    }\n\n    Node* min_node(Node* node) {\n        Node* current = node;\n        while (current && current->lchild != nullptr)\n            current = current->lchild;\n        return current;\n    }\n\n    Node* deleteElement(Node* root, int value) {\n        if (root == nullptr)\n            return root;\n\n        if (value < root->data)\n            root->lchild = deleteElement(root->lchild, value);\n        else if (value > root->data)\n            root->rchild = deleteElement(root->rchild, value);\n        else {\n            if (root->lchild == nullptr) {\n                Node* temp = root->rchild;\n                delete root;\n                return temp;\n            } else if (root->rchild == nullptr) {\n                Node* temp = root->lchild;\n                delete root;\n                return temp;\n            }\n\n            Node* temp = min_node(root->rchild);\n            root->data = temp->data;\n            root->rchild = deleteElement(root->rchild, temp->data);\n        }\n        return root;\n    }\n\n    void inorder_traversal(Node* root){\n        if(root != nullptr){\n            inorder_traversal(root->lchild);\n            cout << root->data << \" \";\n            inorder_traversal(root->rchild);\n        }\n    }\n\n    void Recursive_search(Node* root, int value){\n        if(root == nullptr){\n            cout << \"Value not found! \";\n            return;\n        }\n        if(root->data == value) {\n            cout << \"Element found!\";\n            return;\n        }\n        if(value < root->data){\n            Recursive_search(root->lchild, value);\n        }\n        else if(value > root->data){\n            Recursive_search(root->rchild, value);\n        }\n    }\n\n    void Iterative_search(Node* root, int value){\n        Node* current = root;\n\n        while(current != nullptr && current->data != value){\n            if(value < current->data){\n                current = current->lchild;\n            }\n            else if(value > current->data){\n                current =current->rchild;\n            }\n        }\n        if(current == nullptr){\n            cout << \"Value not found!\";\n        }\n        else{\n            cout << \"Value found!\";\n        }\n    }\n\n    int max_element(Node* root){\n        if (root == nullptr){\n            cout << \"Tree is empty!\";\n            return -1;\n        }\n\n        Node *current = root;\n        while(current->rchild != nullptr){\n            current = current->rchild;\n        }\n        return current->data;\n    }\n\n    int min_element(Node* root){\n        if (root == nullptr){\n            cout << \"Tree is empty!\";\n            return -1;\n        }\n\n        Node *current = root;\n        while(current->lchild != nullptr){\n            current = current->lchild;\n        }\n        return current->data;\n    }\n\n    int inorder_successor(Node* root, int value) {\n        if (root == nullptr) {\n            cout << \"Tree is empty! Cannot find the inorder successor!\\n\";\n            return -1;\n        }\n\n        Node* current = root;\n        Node* target = nullptr;\n        Node* successor = nullptr; \n\n        while (current != nullptr) {\n            if (value < current->data) {\n                successor = current;\n                current = current->lchild;\n            } else if (value > current->data) {\n                current = current->rchild;\n            } else {\n                target = current;\n                break;\n            }\n        }\n\n        if (target == nullptr) {\n            cout << \"Value \" << value << \" not found in the tree.\\n\";\n            return -1;\n        }\n\n        if (target->rchild != nullptr) {\n            Node* temp = min_node(target->rchild);\n            if (temp) {\n                cout << \"The inorder successor of \" << value << \" is \" << temp->data << '\\n';\n                return temp->data;\n            }\n        }\n\n        if (successor != nullptr) {\n            cout << \"The inorder successor of \" << value << \" is \" << successor->data << '\\n';\n            return successor->data;\n        }\n\n        cout << \"The element \" << value << \" has no inorder successor (it's the maximum).\\n\";\n        return -1;\n    }\n\n    int inorder_predecessor(Node* root, int value) {\n        if (root == nullptr) {\n            cout << \"Tree is empty! Cannot find the inorder predecessor!\\n\";\n            return -1;\n        }\n\n        Node* current = root;\n        Node* target = nullptr;\n        Node* predecessor = nullptr;\n\n        while (current != nullptr) {\n            if (value > current->data) {\n                predecessor = current;\n                current = current->rchild;\n            }\n            else if (value < current->data) {\n                current = current->lchild;\n            }\n            else {\n                target = current;\n                break;\n            }\n        }\n\n        if (target == nullptr) {\n            cout << \"Value \" << value << \" not found in the BST.\\n\";\n            return -1;\n        }\n\n        if (target->lchild != nullptr) {\n            Node* temp = target->lchild;\n            while (temp->rchild != nullptr)\n                temp = temp->rchild; \n            cout << \"The inorder predecessor of \" << value << \" is \" << temp->data << '\\n';\n            return temp->data;\n        }\n\n        if (predecessor != nullptr) {\n            cout << \"The inorder predecessor of \" << value << \" is \" << predecessor->data << '\\n';\n            return predecessor->data;\n        }\n\n        cout << \"The element \" << value << \" has no inorder predecessor (it's the minimum).\\n\";\n        return -1;\n    }\n\n    bool isBST_inorder_util(Node* root, int &prev) {\n        if (root == nullptr)\n            return true;\n\n        if (!isBST_inorder_util(root->lchild, prev))\n            return false;\n\n        if (root->data <= prev)\n            return false;\n\n        prev = root->data;\n\n        return isBST_inorder_util(root->rchild, prev);\n    }\n\n    bool isBST(Node* root) {\n        int prev = -1000000000;\n        return isBST_inorder_util(root, prev);\n    }\n};\n\nint main() {\n    BST_implementation B1;\n\n    B1.insert_unique_element(4);\n    B1.insert_unique_element(2);\n    B1.insert_unique_element(6);\n    B1.insert_unique_element(1);\n    B1.insert_unique_element(3);\n    B1.insert_unique_element(5);\n    B1.insert_unique_element(7);\n    B1.deleteElement(B1.root, 7);\n\n    B1.inorder_traversal(B1.root);\n    cout << endl;\n    \n    B1.Iterative_search(B1.root, 2);\n    cout << endl;\n    cout << \"Max: \" << B1.max_element(B1.root) << endl;\n    cout << \"Min: \" << B1.min_element(B1.root) << endl;\n    B1.inorder_successor(B1.root, 3);\n\n    return 0;\n}"
    },
    {
      "id": "A8Q5",
      "question": "Implement Heapsort (Increasing and Decreasing order).",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid siftDownMax(vector<int>& a, int start, int end) {\n    int root = start;\n    while (true) {\n        int left = 2*root + 1;\n        if (left > end) break;\n        int right = left + 1;\n        int idx = left;\n        if (right <= end && a[right] > a[left]) idx = right;\n        if (a[idx] > a[root]) {\n            swap(a[root], a[idx]);\n            root = idx;\n        } else break;\n    }\n}\n\nvoid buildMaxHeap(vector<int>& a) {\n    for (int i = (a.size()-2)/2; i >= 0; i--)\n        siftDownMax(a, i, a.size()-1);\n}\n\nvoid heapsortAsc(vector<int>& a) {\n    buildMaxHeap(a);\n    int end = a.size()-1;\n    while (end > 0) {\n        swap(a[0], a[end]);\n        end--;\n        siftDownMax(a, 0, end);\n    }\n}\n\nvoid siftDownMin(vector<int>& a, int start, int end) {\n    int root = start;\n    while (true) {\n        int left = 2*root + 1;\n        if (left > end) break;\n        int right = left + 1;\n        int idx = left;\n        if (right <= end && a[right] < a[left]) idx = right;\n        if (a[idx] < a[root]) {\n            swap(a[root], a[idx]);\n            root = idx;\n        } else break;\n    }\n}\n\nvoid buildMinHeap(vector<int>& a) {\n    for (int i = (a.size()-2)/2; i >= 0; i--)\n        siftDownMin(a, i, a.size()-1);\n}\n\nvoid heapsortDesc(vector<int>& a) {\n    buildMinHeap(a);\n    int end = a.size()-1;\n    while (end > 0) {\n        swap(a[0], a[end]);\n        end--;\n        siftDownMin(a, 0, end);\n    }\n}\n\nint main() {\n    vector<int> a = {5,3,8,1,9,2};\n    cout << \"Original: 5 3 8 1 9 2\\n\";\n    heapsortAsc(a);\n    cout << \"Sorted Ascending: \";\n    for (int x : a) cout << x << \" \";\n    cout << \"\\n\";\n    \n    vector<int> b = {5,3,8,1,9,2};\n    heapsortDesc(b);\n    cout << \"Sorted Descending: \";\n    for (int x : b) cout << x << \" \";\n    return 0;\n}"
    },
    {
      "id": "A8Q6",
      "question": "Implement priority queues using heaps.",
      "answer": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid siftDownMax(vector<int>& a, int start, int end) {\n    int root = start;\n    while (true) {\n        int left = 2*root + 1;\n        if (left > end) break;\n        int right = left + 1;\n        int idx = left;\n        if (right <= end && a[right] > a[left]) idx = right;\n        if (a[idx] > a[root]) {\n            swap(a[root], a[idx]);\n            root = idx;\n        } else break;\n    }\n}\n\nstruct MaxPQ {\n    vector<int> h;\n\n    void push(int x) {\n        h.push_back(x);\n        int i = h.size()-1;\n        while (i > 0) {\n            int p = (i-1)/2;\n            if (h[p] >= h[i]) break;\n            swap(h[p], h[i]);\n            i = p;\n        }\n    }\n\n    int top() {\n        if (h.empty()) return INT_MIN;\n        return h[0];\n    }\n\n    void pop() {\n        if (h.empty()) return;\n        h[0] = h.back();\n        h.pop_back();\n        if (!h.empty()) siftDownMax(h, 0, h.size()-1);\n    }\n\n    bool empty() {\n        return h.empty();\n    }\n};\n\nint main() {\n    MaxPQ pq;\n    pq.push(10);\n    pq.push(5);\n    pq.push(20);\n    pq.push(1);\n    cout << \"Top element (Max): \" << pq.top() << \"\\n\"; // Expected 20\n    pq.pop();\n    cout << \"Top element after pop: \" << pq.top() << \"\\n\"; // Expected 10\n    return 0;\n}"
    }
    
  ]
}